/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/access/AccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import "./IAccessControl.sol";
   6 |     | import "../utils/Context.sol";
   7 |     | import "../utils/Strings.sol";
   8 |     | import "../utils/introspection/ERC165.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Contract module that allows children to implement role-based access
  12 |     |  * control mechanisms. This is a lightweight version that doesn't allow enumerating role
  13 |     |  * members except through off-chain means by accessing the contract event logs. Some
  14 |     |  * applications may benefit from on-chain enumerability, for those cases see
  15 |     |  * {AccessControlEnumerable}.
  16 |     |  *
  17 |     |  * Roles are referred to by their `bytes32` identifier. These should be exposed
  18 |     |  * in the external API and be unique. The best way to achieve this is by
  19 |     |  * using `public constant` hash digests:
  20 |     |  *
  21 |     |  * ```
  22 |     |  * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
  23 |     |  * ```
  24 |     |  *
  25 |     |  * Roles can be used to represent a set of permissions. To restrict access to a
  26 |     |  * function call, use {hasRole}:
  27 |     |  *
  28 |     |  * ```
  29 |     |  * function foo() public {
  30 |     |  *     require(hasRole(MY_ROLE, msg.sender));
  31 |     |  *     ...
  32 |     |  * }
  33 |     |  * ```
  34 |     |  *
  35 |     |  * Roles can be granted and revoked dynamically via the {grantRole} and
  36 |     |  * {revokeRole} functions. Each role has an associated admin role, and only
  37 |     |  * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
  38 |     |  *
  39 |     |  * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
  40 |     |  * that only accounts with this role will be able to grant or revoke other
  41 |     |  * roles. More complex role relationships can be created by using
  42 |     |  * {_setRoleAdmin}.
  43 |     |  *
  44 |     |  * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
  45 |     |  * grant and revoke this role. Extra precautions should be taken to secure
  46 |     |  * accounts that have been granted it.
  47 |     |  */
  48 |     | abstract contract AccessControl is Context, IAccessControl, ERC165 {
  49 |     |     struct RoleData {
  50 |     |         mapping(address => bool) members;
  51 |     |         bytes32 adminRole;
  52 |     |     }
  53 |     | 
  54 |     |     mapping(bytes32 => RoleData) private _roles;
  55 |     | 
  56 | *   |     bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
  57 |     | 
  58 |     |     /**
  59 |     |      * @dev Modifier that checks that an account has a specific role. Reverts
  60 |     |      * with a standardized message including the required role.
  61 |     |      *
  62 |     |      * The format of the revert reason is given by the following regular expression:
  63 |     |      *
  64 |     |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
  65 |     |      *
  66 |     |      * _Available since v4.1._
  67 |     |      */
  68 |     |     modifier onlyRole(bytes32 role) {
  69 | *   |         _checkRole(role, _msgSender());
  70 |     |         _;
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev See {IERC165-supportsInterface}.
  75 |     |      */
  76 | *   |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  77 | *   |         return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Returns `true` if `account` has been granted `role`.
  82 |     |      */
  83 | *   |     function hasRole(bytes32 role, address account) public view override returns (bool) {
  84 | *   |         return _roles[role].members[account];
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @dev Revert with a standard message if `account` is missing `role`.
  89 |     |      *
  90 |     |      * The format of the revert reason is given by the following regular expression:
  91 |     |      *
  92 |     |      *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
  93 |     |      */
  94 | *   |     function _checkRole(bytes32 role, address account) internal view {
  95 | *   |         if (!hasRole(role, account)) {
  96 | *r  |             revert(
  97 |     |                 string(
  98 | *   |                     abi.encodePacked(
  99 |     |                         "AccessControl: account ",
 100 | *   |                         Strings.toHexString(uint160(account), 20),
 101 |     |                         " is missing role ",
 102 | *   |                         Strings.toHexString(uint256(role), 32)
 103 |     |                     )
 104 |     |                 )
 105 |     |             );
 106 |     |         }
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
 111 |     |      * {revokeRole}.
 112 |     |      *
 113 |     |      * To change a role's admin, use {_setRoleAdmin}.
 114 |     |      */
 115 | *   |     function getRoleAdmin(bytes32 role) public view override returns (bytes32) {
 116 | *   |         return _roles[role].adminRole;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev Grants `role` to `account`.
 121 |     |      *
 122 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 123 |     |      * event.
 124 |     |      *
 125 |     |      * Requirements:
 126 |     |      *
 127 |     |      * - the caller must have ``role``'s admin role.
 128 |     |      */
 129 | *   |     function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
 130 |     |         _grantRole(role, account);
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @dev Revokes `role` from `account`.
 135 |     |      *
 136 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
 137 |     |      *
 138 |     |      * Requirements:
 139 |     |      *
 140 |     |      * - the caller must have ``role``'s admin role.
 141 |     |      */
 142 | *   |     function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {
 143 |     |         _revokeRole(role, account);
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @dev Revokes `role` from the calling account.
 148 |     |      *
 149 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
 150 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
 151 |     |      * if they are compromised (such as when a trusted device is misplaced).
 152 |     |      *
 153 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
 154 |     |      * event.
 155 |     |      *
 156 |     |      * Requirements:
 157 |     |      *
 158 |     |      * - the caller must be `account`.
 159 |     |      */
 160 | *   |     function renounceRole(bytes32 role, address account) public virtual override {
 161 | *r  |         require(account == _msgSender(), "AccessControl: can only renounce roles for self");
 162 |     | 
 163 | *   |         _revokeRole(role, account);
 164 |     |     }
 165 |     | 
 166 |     |     /**
 167 |     |      * @dev Grants `role` to `account`.
 168 |     |      *
 169 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
 170 |     |      * event. Note that unlike {grantRole}, this function doesn't perform any
 171 |     |      * checks on the calling account.
 172 |     |      *
 173 |     |      * [WARNING]
 174 |     |      * ====
 175 |     |      * This function should only be called from the constructor when setting
 176 |     |      * up the initial roles for the system.
 177 |     |      *
 178 |     |      * Using this function in any other way is effectively circumventing the admin
 179 |     |      * system imposed by {AccessControl}.
 180 |     |      * ====
 181 |     |      */
 182 | *   |     function _setupRole(bytes32 role, address account) internal virtual {
 183 | *   |         _grantRole(role, account);
 184 |     |     }
 185 |     | 
 186 |     |     /**
 187 |     |      * @dev Sets `adminRole` as ``role``'s admin role.
 188 |     |      *
 189 |     |      * Emits a {RoleAdminChanged} event.
 190 |     |      */
 191 |     |     function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
 192 |     |         bytes32 previousAdminRole = getRoleAdmin(role);
 193 |     |         _roles[role].adminRole = adminRole;
 194 |     |         emit RoleAdminChanged(role, previousAdminRole, adminRole);
 195 |     |     }
 196 |     | 
 197 | *   |     function _grantRole(bytes32 role, address account) private {
 198 | *   |         if (!hasRole(role, account)) {
 199 | *   |             _roles[role].members[account] = true;
 200 | *   |             emit RoleGranted(role, account, _msgSender());
 201 |     |         }
 202 |     |     }
 203 |     | 
 204 | *   |     function _revokeRole(bytes32 role, address account) private {
 205 | *   |         if (hasRole(role, account)) {
 206 |     |             _roles[role].members[account] = false;
 207 |     |             emit RoleRevoked(role, account, _msgSender());
 208 |     |         }
 209 |     |     }
 210 |     | }
 211 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/access/IAccessControl.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (access/IAccessControl.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev External interface of AccessControl declared to support ERC-165 detection.
   8 |     |  */
   9 |     | interface IAccessControl {
  10 |     |     /**
  11 |     |      * @dev The `account` is missing a role.
  12 |     |      */
  13 |     |     error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
  14 |     | 
  15 |     |     /**
  16 |     |      * @dev The caller of a function is not the expected one.
  17 |     |      *
  18 |     |      * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
  19 |     |      */
  20 |     |     error AccessControlBadConfirmation();
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
  24 |     |      *
  25 |     |      * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
  26 |     |      * {RoleAdminChanged} not being emitted signaling this.
  27 |     |      */
  28 |     |     event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Emitted when `account` is granted `role`.
  32 |     |      *
  33 |     |      * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).
  34 |     |      * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.
  35 |     |      */
  36 |     |     event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Emitted when `account` is revoked `role`.
  40 |     |      *
  41 |     |      * `sender` is the account that originated the contract call:
  42 |     |      *   - if using `revokeRole`, it is the admin role bearer
  43 |     |      *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
  44 |     |      */
  45 |     |     event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Returns `true` if `account` has been granted `role`.
  49 |     |      */
  50 |     |     function hasRole(bytes32 role, address account) external view returns (bool);
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Returns the admin role that controls `role`. See {grantRole} and
  54 |     |      * {revokeRole}.
  55 |     |      *
  56 |     |      * To change a role's admin, use {AccessControl-_setRoleAdmin}.
  57 |     |      */
  58 |     |     function getRoleAdmin(bytes32 role) external view returns (bytes32);
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Grants `role` to `account`.
  62 |     |      *
  63 |     |      * If `account` had not been already granted `role`, emits a {RoleGranted}
  64 |     |      * event.
  65 |     |      *
  66 |     |      * Requirements:
  67 |     |      *
  68 |     |      * - the caller must have ``role``'s admin role.
  69 |     |      */
  70 |     |     function grantRole(bytes32 role, address account) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Revokes `role` from `account`.
  74 |     |      *
  75 |     |      * If `account` had been granted `role`, emits a {RoleRevoked} event.
  76 |     |      *
  77 |     |      * Requirements:
  78 |     |      *
  79 |     |      * - the caller must have ``role``'s admin role.
  80 |     |      */
  81 |     |     function revokeRole(bytes32 role, address account) external;
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Revokes `role` from the calling account.
  85 |     |      *
  86 |     |      * Roles are often managed via {grantRole} and {revokeRole}: this function's
  87 |     |      * purpose is to provide a mechanism for accounts to lose their privileges
  88 |     |      * if they are compromised (such as when a trusted device is misplaced).
  89 |     |      *
  90 |     |      * If the calling account had been granted `role`, emits a {RoleRevoked}
  91 |     |      * event.
  92 |     |      *
  93 |     |      * Requirements:
  94 |     |      *
  95 |     |      * - the caller must be `callerConfirmation`.
  96 |     |      */
  97 |     |     function renounceRole(bytes32 role, address callerConfirmation) external;
  98 |     | }
  99 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import "./IERC20.sol";
   6 |     | import "./extensions/IERC20Metadata.sol";
   7 |     | import "../../utils/Context.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Implementation of the {IERC20} interface.
  11 |     |  *
  12 |     |  * This implementation is agnostic to the way tokens are created. This means
  13 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  14 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  15 |     |  *
  16 |     |  * TIP: For a detailed writeup see our guide
  17 |     |  * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
  18 |     |  * to implement supply mechanisms].
  19 |     |  *
  20 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  21 |     |  * instead returning `false` on failure. This behavior is nonetheless
  22 |     |  * conventional and does not conflict with the expectations of ERC20
  23 |     |  * applications.
  24 |     |  *
  25 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  26 |     |  * This allows applications to reconstruct the allowance for all accounts just
  27 |     |  * by listening to said events. Other implementations of the EIP may not emit
  28 |     |  * these events, as it isn't required by the specification.
  29 |     |  *
  30 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  31 |     |  * functions have been added to mitigate the well-known issues around setting
  32 |     |  * allowances. See {IERC20-approve}.
  33 |     |  */
  34 | *r  | contract ERC20 is Context, IERC20, IERC20Metadata {
  35 |     |     mapping(address => uint256) private _balances;
  36 |     | 
  37 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  38 |     | 
  39 |     |     uint256 private _totalSupply;
  40 |     | 
  41 |     |     string private _name;
  42 |     |     string private _symbol;
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Sets the values for {name} and {symbol}.
  46 |     |      *
  47 |     |      * The default value of {decimals} is 18. To select a different value for
  48 |     |      * {decimals} you should overload it.
  49 |     |      *
  50 |     |      * All two of these values are immutable: they can only be set once during
  51 |     |      * construction.
  52 |     |      */
  53 | *   |     constructor(string memory name_, string memory symbol_) {
  54 | *   |         _name = name_;
  55 | *   |         _symbol = symbol_;
  56 |     |     }
  57 |     | 
  58 |     |     /**
  59 |     |      * @dev Returns the name of the token.
  60 |     |      */
  61 | *   |     function name() public view virtual override returns (string memory) {
  62 | *   |         return _name;
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  67 |     |      * name.
  68 |     |      */
  69 | *   |     function symbol() public view virtual override returns (string memory) {
  70 | *   |         return _symbol;
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Returns the number of decimals used to get its user representation.
  75 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  76 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  77 |     |      *
  78 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  79 |     |      * Ether and Wei. This is the value {ERC20} uses, unless this function is
  80 |     |      * overridden;
  81 |     |      *
  82 |     |      * NOTE: This information is only used for _display_ purposes: it in
  83 |     |      * no way affects any of the arithmetic of the contract, including
  84 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  85 |     |      */
  86 | *   |     function decimals() public view virtual override returns (uint8) {
  87 | *   |         return 18;
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev See {IERC20-totalSupply}.
  92 |     |      */
  93 | *   |     function totalSupply() public view virtual override returns (uint256) {
  94 | *   |         return _totalSupply;
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @dev See {IERC20-balanceOf}.
  99 |     |      */
 100 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 101 | *   |         return _balances[account];
 102 |     |     }
 103 |     | 
 104 |     |     /**
 105 |     |      * @dev See {IERC20-transfer}.
 106 |     |      *
 107 |     |      * Requirements:
 108 |     |      *
 109 |     |      * - `recipient` cannot be the zero address.
 110 |     |      * - the caller must have a balance of at least `amount`.
 111 |     |      */
 112 | *   |     function transfer(address recipient, uint256 amount) public virtual override returns (bool) {
 113 | *   |         _transfer(_msgSender(), recipient, amount);
 114 | *   |         return true;
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @dev See {IERC20-allowance}.
 119 |     |      */
 120 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 121 | *   |         return _allowances[owner][spender];
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev See {IERC20-approve}.
 126 |     |      *
 127 |     |      * Requirements:
 128 |     |      *
 129 |     |      * - `spender` cannot be the zero address.
 130 |     |      */
 131 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 132 | *   |         _approve(_msgSender(), spender, amount);
 133 | *   |         return true;
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @dev See {IERC20-transferFrom}.
 138 |     |      *
 139 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 140 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 141 |     |      *
 142 |     |      * Requirements:
 143 |     |      *
 144 |     |      * - `sender` and `recipient` cannot be the zero address.
 145 |     |      * - `sender` must have a balance of at least `amount`.
 146 |     |      * - the caller must have allowance for ``sender``'s tokens of at least
 147 |     |      * `amount`.
 148 |     |      */
 149 | *   |     function transferFrom(
 150 |     |         address sender,
 151 |     |         address recipient,
 152 |     |         uint256 amount
 153 | *   |     ) public virtual override returns (bool) {
 154 | *   |         _transfer(sender, recipient, amount);
 155 |     | 
 156 | *   |         uint256 currentAllowance = _allowances[sender][_msgSender()];
 157 | *   |         require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");
 158 |     |         unchecked {
 159 | *   |             _approve(sender, _msgSender(), currentAllowance - amount);
 160 |     |         }
 161 |     | 
 162 | *   |         return true;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 167 |     |      *
 168 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 169 |     |      * problems described in {IERC20-approve}.
 170 |     |      *
 171 |     |      * Emits an {Approval} event indicating the updated allowance.
 172 |     |      *
 173 |     |      * Requirements:
 174 |     |      *
 175 |     |      * - `spender` cannot be the zero address.
 176 |     |      */
 177 | *   |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 178 | *   |         _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);
 179 | *   |         return true;
 180 |     |     }
 181 |     | 
 182 |     |     /**
 183 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 184 |     |      *
 185 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 186 |     |      * problems described in {IERC20-approve}.
 187 |     |      *
 188 |     |      * Emits an {Approval} event indicating the updated allowance.
 189 |     |      *
 190 |     |      * Requirements:
 191 |     |      *
 192 |     |      * - `spender` cannot be the zero address.
 193 |     |      * - `spender` must have allowance for the caller of at least
 194 |     |      * `subtractedValue`.
 195 |     |      */
 196 | *   |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 197 | *   |         uint256 currentAllowance = _allowances[_msgSender()][spender];
 198 | *r  |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 199 |     |         unchecked {
 200 | *   |             _approve(_msgSender(), spender, currentAllowance - subtractedValue);
 201 |     |         }
 202 |     | 
 203 | *   |         return true;
 204 |     |     }
 205 |     | 
 206 |     |     /**
 207 |     |      * @dev Moves `amount` of tokens from `sender` to `recipient`.
 208 |     |      *
 209 |     |      * This internal function is equivalent to {transfer}, and can be used to
 210 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 211 |     |      *
 212 |     |      * Emits a {Transfer} event.
 213 |     |      *
 214 |     |      * Requirements:
 215 |     |      *
 216 |     |      * - `sender` cannot be the zero address.
 217 |     |      * - `recipient` cannot be the zero address.
 218 |     |      * - `sender` must have a balance of at least `amount`.
 219 |     |      */
 220 | *   |     function _transfer(
 221 |     |         address sender,
 222 |     |         address recipient,
 223 |     |         uint256 amount
 224 | *   |     ) internal virtual {
 225 | *   |         require(sender != address(0), "ERC20: transfer from the zero address");
 226 | *r  |         require(recipient != address(0), "ERC20: transfer to the zero address");
 227 |     | 
 228 | *   |         _beforeTokenTransfer(sender, recipient, amount);
 229 |     | 
 230 | *   |         uint256 senderBalance = _balances[sender];
 231 | *r  |         require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");
 232 |     |         unchecked {
 233 | *   |             _balances[sender] = senderBalance - amount;
 234 |     |         }
 235 | *   |         _balances[recipient] += amount;
 236 |     | 
 237 | *   |         emit Transfer(sender, recipient, amount);
 238 |     | 
 239 | *   |         _afterTokenTransfer(sender, recipient, amount);
 240 |     |     }
 241 |     | 
 242 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 243 |     |      * the total supply.
 244 |     |      *
 245 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `account` cannot be the zero address.
 250 |     |      */
 251 | *   |     function _mint(address account, uint256 amount) internal virtual {
 252 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 253 |     | 
 254 | *   |         _beforeTokenTransfer(address(0), account, amount);
 255 |     | 
 256 | *   |         _totalSupply += amount;
 257 | *   |         _balances[account] += amount;
 258 | *   |         emit Transfer(address(0), account, amount);
 259 |     | 
 260 | *   |         _afterTokenTransfer(address(0), account, amount);
 261 |     |     }
 262 |     | 
 263 |     |     /**
 264 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 265 |     |      * total supply.
 266 |     |      *
 267 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 268 |     |      *
 269 |     |      * Requirements:
 270 |     |      *
 271 |     |      * - `account` cannot be the zero address.
 272 |     |      * - `account` must have at least `amount` tokens.
 273 |     |      */
 274 | *   |     function _burn(address account, uint256 amount) internal virtual {
 275 | *   |         require(account != address(0), "ERC20: burn from the zero address");
 276 |     | 
 277 | *   |         _beforeTokenTransfer(account, address(0), amount);
 278 |     | 
 279 | *   |         uint256 accountBalance = _balances[account];
 280 | *   |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 281 |     |         unchecked {
 282 | *   |             _balances[account] = accountBalance - amount;
 283 |     |         }
 284 | *   |         _totalSupply -= amount;
 285 |     | 
 286 | *   |         emit Transfer(account, address(0), amount);
 287 |     | 
 288 | *   |         _afterTokenTransfer(account, address(0), amount);
 289 |     |     }
 290 |     | 
 291 |     |     /**
 292 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 293 |     |      *
 294 |     |      * This internal function is equivalent to `approve`, and can be used to
 295 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 296 |     |      *
 297 |     |      * Emits an {Approval} event.
 298 |     |      *
 299 |     |      * Requirements:
 300 |     |      *
 301 |     |      * - `owner` cannot be the zero address.
 302 |     |      * - `spender` cannot be the zero address.
 303 |     |      */
 304 | *   |     function _approve(
 305 |     |         address owner,
 306 |     |         address spender,
 307 |     |         uint256 amount
 308 |     |     ) internal virtual {
 309 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 310 | *r  |         require(spender != address(0), "ERC20: approve to the zero address");
 311 |     | 
 312 | *   |         _allowances[owner][spender] = amount;
 313 | *   |         emit Approval(owner, spender, amount);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 318 |     |      * minting and burning.
 319 |     |      *
 320 |     |      * Calling conditions:
 321 |     |      *
 322 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 323 |     |      * will be transferred to `to`.
 324 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 325 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 326 |     |      * - `from` and `to` are never both zero.
 327 |     |      *
 328 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 329 |     |      */
 330 | *   |     function _beforeTokenTransfer(
 331 |     |         address from,
 332 |     |         address to,
 333 |     |         uint256 amount
 334 |     |     ) internal virtual {}
 335 |     | 
 336 |     |     /**
 337 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 338 |     |      * minting and burning.
 339 |     |      *
 340 |     |      * Calling conditions:
 341 |     |      *
 342 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 343 |     |      * has been transferred to `to`.
 344 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 345 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 346 |     |      * - `from` and `to` are never both zero.
 347 |     |      *
 348 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 349 |     |      */
 350 | *   |     function _afterTokenTransfer(
 351 |     |         address from,
 352 |     |         address to,
 353 |     |         uint256 amount
 354 |     |     ) internal virtual {}
 355 |     | }
 356 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  7 |     |  */
  8 |     | interface IERC20 {
  9 |     |     /**
 10 |     |      * @dev Returns the amount of tokens in existence.
 11 |     |      */
 12 |     |     function totalSupply() external view returns (uint256);
 13 |     | 
 14 |     |     /**
 15 |     |      * @dev Returns the amount of tokens owned by `account`.
 16 |     |      */
 17 |     |     function balanceOf(address account) external view returns (uint256);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Moves `amount` tokens from the caller's account to `recipient`.
 21 |     |      *
 22 |     |      * Returns a boolean value indicating whether the operation succeeded.
 23 |     |      *
 24 |     |      * Emits a {Transfer} event.
 25 |     |      */
 26 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 30 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 31 |     |      * zero by default.
 32 |     |      *
 33 |     |      * This value changes when {approve} or {transferFrom} are called.
 34 |     |      */
 35 |     |     function allowance(address owner, address spender) external view returns (uint256);
 36 |     | 
 37 |     |     /**
 38 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 39 |     |      *
 40 |     |      * Returns a boolean value indicating whether the operation succeeded.
 41 |     |      *
 42 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 43 |     |      * that someone may use both the old and the new allowance by unfortunate
 44 |     |      * transaction ordering. One possible solution to mitigate this race
 45 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 46 |     |      * desired value afterwards:
 47 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 48 |     |      *
 49 |     |      * Emits an {Approval} event.
 50 |     |      */
 51 |     |     function approve(address spender, uint256 amount) external returns (bool);
 52 |     | 
 53 |     |     /**
 54 |     |      * @dev Moves `amount` tokens from `sender` to `recipient` using the
 55 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 56 |     |      * allowance.
 57 |     |      *
 58 |     |      * Returns a boolean value indicating whether the operation succeeded.
 59 |     |      *
 60 |     |      * Emits a {Transfer} event.
 61 |     |      */
 62 |     |     function transferFrom(
 63 |     |         address sender,
 64 |     |         address recipient,
 65 |     |         uint256 amount
 66 |     |     ) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 70 |     |      * another (`to`).
 71 |     |      *
 72 |     |      * Note that `value` may be zero.
 73 |     |      */
 74 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 78 |     |      * a call to {approve}. `value` is the new allowance.
 79 |     |      */
 80 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 81 |     | }
 82 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Snapshot.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import "../ERC20.sol";
   6 |     | import "../../../utils/Arrays.sol";
   7 |     | import "../../../utils/Counters.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and
  11 |     |  * total supply at the time are recorded for later access.
  12 |     |  *
  13 |     |  * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.
  14 |     |  * In naive implementations it's possible to perform a "double spend" attack by reusing the same balance from different
  15 |     |  * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be
  16 |     |  * used to create an efficient ERC20 forking mechanism.
  17 |     |  *
  18 |     |  * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a
  19 |     |  * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot
  20 |     |  * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id
  21 |     |  * and the account address.
  22 |     |  *
  23 |     |  * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it
  24 |     |  * return `block.number` will trigger the creation of snapshot at the begining of each new block. When overridding this
  25 |     |  * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.
  26 |     |  *
  27 |     |  * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient
  28 |     |  * alternative consider {ERC20Votes}.
  29 |     |  *
  30 |     |  * ==== Gas Costs
  31 |     |  *
  32 |     |  * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log
  33 |     |  * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much
  34 |     |  * smaller since identical balances in subsequent snapshots are stored as a single entry.
  35 |     |  *
  36 |     |  * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is
  37 |     |  * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent
  38 |     |  * transfers will have normal cost until the next snapshot, and so on.
  39 |     |  */
  40 |     | 
  41 |     | abstract contract ERC20Snapshot is ERC20 {
  42 |     |     // Inspired by Jordi Baylina's MiniMeToken to record historical balances:
  43 |     |     // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol
  44 |     | 
  45 |     |     using Arrays for uint256[];
  46 |     |     using Counters for Counters.Counter;
  47 |     | 
  48 |     |     // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a
  49 |     |     // Snapshot struct, but that would impede usage of functions that work on an array.
  50 |     |     struct Snapshots {
  51 |     |         uint256[] ids;
  52 |     |         uint256[] values;
  53 |     |     }
  54 |     | 
  55 |     |     mapping(address => Snapshots) private _accountBalanceSnapshots;
  56 |     |     Snapshots private _totalSupplySnapshots;
  57 |     | 
  58 |     |     // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.
  59 |     |     Counters.Counter private _currentSnapshotId;
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.
  63 |     |      */
  64 |     |     event Snapshot(uint256 id);
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Creates a new snapshot and returns its snapshot id.
  68 |     |      *
  69 |     |      * Emits a {Snapshot} event that contains the same id.
  70 |     |      *
  71 |     |      * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a
  72 |     |      * set of accounts, for example using {AccessControl}, or it may be open to the public.
  73 |     |      *
  74 |     |      * [WARNING]
  75 |     |      * ====
  76 |     |      * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,
  77 |     |      * you must consider that it can potentially be used by attackers in two ways.
  78 |     |      *
  79 |     |      * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow
  80 |     |      * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target
  81 |     |      * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs
  82 |     |      * section above.
  83 |     |      *
  84 |     |      * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.
  85 |     |      * ====
  86 |     |      */
  87 | *   |     function _snapshot() internal virtual returns (uint256) {
  88 | *   |         _currentSnapshotId.increment();
  89 |     | 
  90 | *   |         uint256 currentId = _getCurrentSnapshotId();
  91 | *   |         emit Snapshot(currentId);
  92 | *   |         return currentId;
  93 |     |     }
  94 |     | 
  95 |     |     /**
  96 |     |      * @dev Get the current snapshotId
  97 |     |      */
  98 | *   |     function _getCurrentSnapshotId() internal view virtual returns (uint256) {
  99 | *   |         return _currentSnapshotId.current();
 100 |     |     }
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Retrieves the balance of `account` at the time `snapshotId` was created.
 104 |     |      */
 105 | *   |     function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {
 106 | *   |         (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);
 107 |     | 
 108 | *   |         return snapshotted ? value : balanceOf(account);
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Retrieves the total supply at the time `snapshotId` was created.
 113 |     |      */
 114 | *   |     function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {
 115 | *   |         (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);
 116 |     | 
 117 | *   |         return snapshotted ? value : totalSupply();
 118 |     |     }
 119 |     | 
 120 |     |     // Update balance and/or total supply snapshots before the values are modified. This is implemented
 121 |     |     // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.
 122 | *   |     function _beforeTokenTransfer(
 123 |     |         address from,
 124 |     |         address to,
 125 |     |         uint256 amount
 126 |     |     ) internal virtual override {
 127 | *   |         super._beforeTokenTransfer(from, to, amount);
 128 |     | 
 129 | *   |         if (from == address(0)) {
 130 |     |             // mint
 131 | *   |             _updateAccountSnapshot(to);
 132 | *   |             _updateTotalSupplySnapshot();
 133 | *   |         } else if (to == address(0)) {
 134 |     |             // burn
 135 | *   |             _updateAccountSnapshot(from);
 136 | *   |             _updateTotalSupplySnapshot();
 137 |     |         } else {
 138 |     |             // transfer
 139 | *   |             _updateAccountSnapshot(from);
 140 | *   |             _updateAccountSnapshot(to);
 141 |     |         }
 142 |     |     }
 143 |     | 
 144 | *   |     function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {
 145 | *r  |         require(snapshotId > 0, "ERC20Snapshot: id is 0");
 146 | *r  |         require(snapshotId <= _getCurrentSnapshotId(), "ERC20Snapshot: nonexistent id");
 147 |     | 
 148 |     |         // When a valid snapshot is queried, there are three possibilities:
 149 |     |         //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never
 150 |     |         //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds
 151 |     |         //  to this id is the current one.
 152 |     |         //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the
 153 |     |         //  requested id, and its value is the one to return.
 154 |     |         //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be
 155 |     |         //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is
 156 |     |         //  larger than the requested one.
 157 |     |         //
 158 |     |         // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if
 159 |     |         // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does
 160 |     |         // exactly this.
 161 |     | 
 162 | *   |         uint256 index = snapshots.ids.findUpperBound(snapshotId);
 163 |     | 
 164 | *   |         if (index == snapshots.ids.length) {
 165 | *   |             return (false, 0);
 166 |     |         } else {
 167 | *   |             return (true, snapshots.values[index]);
 168 |     |         }
 169 |     |     }
 170 |     | 
 171 | *   |     function _updateAccountSnapshot(address account) private {
 172 | *   |         _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));
 173 |     |     }
 174 |     | 
 175 | *   |     function _updateTotalSupplySnapshot() private {
 176 | *   |         _updateSnapshot(_totalSupplySnapshots, totalSupply());
 177 |     |     }
 178 |     | 
 179 | *   |     function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {
 180 | *   |         uint256 currentId = _getCurrentSnapshotId();
 181 | *   |         if (_lastSnapshotId(snapshots.ids) < currentId) {
 182 | *   |             snapshots.ids.push(currentId);
 183 | *   |             snapshots.values.push(currentValue);
 184 |     |         }
 185 |     |     }
 186 |     | 
 187 | *   |     function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {
 188 | *   |         if (ids.length == 0) {
 189 | *   |             return 0;
 190 |     |         } else {
 191 | *   |             return ids[ids.length - 1];
 192 |     |         }
 193 |     |     }
 194 |     | }
 195 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | import {IERC20} from "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC-20 standard.
 10 |     |  */
 11 |     | interface IERC20Metadata is IERC20 {
 12 |     |     /**
 13 |     |      * @dev Returns the name of the token.
 14 |     |      */
 15 |     |     function name() external view returns (string memory);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the symbol of the token.
 19 |     |      */
 20 |     |     function symbol() external view returns (string memory);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Returns the decimals places of the token.
 24 |     |      */
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | /**
   6 |     |  * @dev Collection of functions related to the address type
   7 |     |  */
   8 |     | library Address {
   9 |     |     /**
  10 |     |      * @dev Returns true if `account` is a contract.
  11 |     |      *
  12 |     |      * [IMPORTANT]
  13 |     |      * ====
  14 |     |      * It is unsafe to assume that an address for which this function returns
  15 |     |      * false is an externally-owned account (EOA) and not a contract.
  16 |     |      *
  17 |     |      * Among others, `isContract` will return false for the following
  18 |     |      * types of addresses:
  19 |     |      *
  20 |     |      *  - an externally-owned account
  21 |     |      *  - a contract in construction
  22 |     |      *  - an address where a contract will be created
  23 |     |      *  - an address where a contract lived, but was destroyed
  24 |     |      * ====
  25 |     |      */
  26 | *   |     function isContract(address account) internal view returns (bool) {
  27 |     |         // This method relies on extcodesize, which returns 0 for contracts in
  28 |     |         // construction, since the code is only stored at the end of the
  29 |     |         // constructor execution.
  30 |     | 
  31 | *   |         uint256 size;
  32 |     |         assembly {
  33 | *   |             size := extcodesize(account)
  34 |     |         }
  35 | *   |         return size > 0;
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  40 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  41 |     |      *
  42 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  43 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  44 |     |      * imposed by `transfer`, making them unable to receive funds via
  45 |     |      * `transfer`. {sendValue} removes this limitation.
  46 |     |      *
  47 |     |      * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  48 |     |      *
  49 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  50 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  51 |     |      * {ReentrancyGuard} or the
  52 |     |      * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  53 |     |      */
  54 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  55 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  56 |     | 
  57 |     |         (bool success, ) = recipient.call{value: amount}("");
  58 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  63 |     |      * plain `call` is an unsafe replacement for a function call: use this
  64 |     |      * function instead.
  65 |     |      *
  66 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  67 |     |      * function (like regular Solidity function calls).
  68 |     |      *
  69 |     |      * Returns the raw returned data. To convert to the expected return value,
  70 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  71 |     |      *
  72 |     |      * Requirements:
  73 |     |      *
  74 |     |      * - `target` must be a contract.
  75 |     |      * - calling `target` with `data` must not revert.
  76 |     |      *
  77 |     |      * _Available since v3.1._
  78 |     |      */
  79 | *   |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  80 | *   |         return functionCall(target, data, "Address: low-level call failed");
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  85 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 | *   |     function functionCall(
  90 |     |         address target,
  91 |     |         bytes memory data,
  92 |     |         string memory errorMessage
  93 | *   |     ) internal returns (bytes memory) {
  94 | *   |         return functionCallWithValue(target, data, 0, errorMessage);
  95 |     |     }
  96 |     | 
  97 |     |     /**
  98 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
  99 |     |      * but also transferring `value` wei to `target`.
 100 |     |      *
 101 |     |      * Requirements:
 102 |     |      *
 103 |     |      * - the calling contract must have an ETH balance of at least `value`.
 104 |     |      * - the called Solidity function must be `payable`.
 105 |     |      *
 106 |     |      * _Available since v3.1._
 107 |     |      */
 108 |     |     function functionCallWithValue(
 109 |     |         address target,
 110 |     |         bytes memory data,
 111 |     |         uint256 value
 112 |     |     ) internal returns (bytes memory) {
 113 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 114 |     |     }
 115 |     | 
 116 |     |     /**
 117 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 118 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 119 |     |      *
 120 |     |      * _Available since v3.1._
 121 |     |      */
 122 | *   |     function functionCallWithValue(
 123 |     |         address target,
 124 |     |         bytes memory data,
 125 |     |         uint256 value,
 126 |     |         string memory errorMessage
 127 | *   |     ) internal returns (bytes memory) {
 128 | *   |         require(address(this).balance >= value, "Address: insufficient balance for call");
 129 | *   |         require(isContract(target), "Address: call to non-contract");
 130 |     | 
 131 | *   |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 132 | *   |         return verifyCallResult(success, returndata, errorMessage);
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 137 |     |      * but performing a static call.
 138 |     |      *
 139 |     |      * _Available since v3.3._
 140 |     |      */
 141 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 142 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 143 |     |     }
 144 |     | 
 145 |     |     /**
 146 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 147 |     |      * but performing a static call.
 148 |     |      *
 149 |     |      * _Available since v3.3._
 150 |     |      */
 151 |     |     function functionStaticCall(
 152 |     |         address target,
 153 |     |         bytes memory data,
 154 |     |         string memory errorMessage
 155 |     |     ) internal view returns (bytes memory) {
 156 |     |         require(isContract(target), "Address: static call to non-contract");
 157 |     | 
 158 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 159 |     |         return verifyCallResult(success, returndata, errorMessage);
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 164 |     |      * but performing a delegate call.
 165 |     |      *
 166 |     |      * _Available since v3.4._
 167 |     |      */
 168 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 169 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 174 |     |      * but performing a delegate call.
 175 |     |      *
 176 |     |      * _Available since v3.4._
 177 |     |      */
 178 |     |     function functionDelegateCall(
 179 |     |         address target,
 180 |     |         bytes memory data,
 181 |     |         string memory errorMessage
 182 |     |     ) internal returns (bytes memory) {
 183 |     |         require(isContract(target), "Address: delegate call to non-contract");
 184 |     | 
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResult(success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the
 191 |     |      * revert reason using the provided one.
 192 |     |      *
 193 |     |      * _Available since v4.3._
 194 |     |      */
 195 | *   |     function verifyCallResult(
 196 |     |         bool success,
 197 |     |         bytes memory returndata,
 198 |     |         string memory errorMessage
 199 | *   |     ) internal pure returns (bytes memory) {
 200 | *   |         if (success) {
 201 | *   |             return returndata;
 202 |     |         } else {
 203 |     |             // Look for revert reason and bubble it up if present
 204 | *   |             if (returndata.length > 0) {
 205 |     |                 // The easiest way to bubble the revert reason is using memory via assembly
 206 |     | 
 207 |     |                 assembly {
 208 | *   |                     let returndata_size := mload(returndata)
 209 | *   |                     revert(add(32, returndata), returndata_size)
 210 |     |                 }
 211 |     |             } else {
 212 |     |                 revert(errorMessage);
 213 |     |             }
 214 |     |         }
 215 |     |     }
 216 |     | }
 217 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/Arrays.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/Arrays.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/Arrays.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | import {Comparators} from "./Comparators.sol";
   8 |     | import {SlotDerivation} from "./SlotDerivation.sol";
   9 |     | import {StorageSlot} from "./StorageSlot.sol";
  10 |     | import {Math} from "./math/Math.sol";
  11 |     | 
  12 |     | /**
  13 |     |  * @dev Collection of functions related to array types.
  14 |     |  */
  15 |     | library Arrays {
  16 |     |     using SlotDerivation for bytes32;
  17 |     |     using StorageSlot for bytes32;
  18 |     | 
  19 |     |     /**
  20 |     |      * @dev Sort an array of uint256 (in memory) following the provided comparator function.
  21 |     |      *
  22 |     |      * This function does the sorting "in place", meaning that it overrides the input. The object is returned for
  23 |     |      * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.
  24 |     |      *
  25 |     |      * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the
  26 |     |      * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful
  27 |     |      * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may
  28 |     |      * consume more gas than is available in a block, leading to potential DoS.
  29 |     |      *
  30 |     |      * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.
  31 |     |      */
  32 |     |     function sort(
  33 |     |         uint256[] memory array,
  34 |     |         function(uint256, uint256) pure returns (bool) comp
  35 |     |     ) internal pure returns (uint256[] memory) {
  36 |     |         _quickSort(_begin(array), _end(array), comp);
  37 |     |         return array;
  38 |     |     }
  39 |     | 
  40 |     |     /**
  41 |     |      * @dev Variant of {sort} that sorts an array of uint256 in increasing order.
  42 |     |      */
  43 |     |     function sort(uint256[] memory array) internal pure returns (uint256[] memory) {
  44 |     |         sort(array, Comparators.lt);
  45 |     |         return array;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sort an array of address (in memory) following the provided comparator function.
  50 |     |      *
  51 |     |      * This function does the sorting "in place", meaning that it overrides the input. The object is returned for
  52 |     |      * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.
  53 |     |      *
  54 |     |      * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the
  55 |     |      * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful
  56 |     |      * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may
  57 |     |      * consume more gas than is available in a block, leading to potential DoS.
  58 |     |      *
  59 |     |      * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.
  60 |     |      */
  61 |     |     function sort(
  62 |     |         address[] memory array,
  63 |     |         function(address, address) pure returns (bool) comp
  64 |     |     ) internal pure returns (address[] memory) {
  65 |     |         sort(_castToUint256Array(array), _castToUint256Comp(comp));
  66 |     |         return array;
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Variant of {sort} that sorts an array of address in increasing order.
  71 |     |      */
  72 |     |     function sort(address[] memory array) internal pure returns (address[] memory) {
  73 |     |         sort(_castToUint256Array(array), Comparators.lt);
  74 |     |         return array;
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Sort an array of bytes32 (in memory) following the provided comparator function.
  79 |     |      *
  80 |     |      * This function does the sorting "in place", meaning that it overrides the input. The object is returned for
  81 |     |      * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.
  82 |     |      *
  83 |     |      * NOTE: this function's cost is `O(n  log(n))` in average and `O(n)` in the worst case, with n the length of the
  84 |     |      * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful
  85 |     |      * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may
  86 |     |      * consume more gas than is available in a block, leading to potential DoS.
  87 |     |      *
  88 |     |      * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.
  89 |     |      */
  90 |     |     function sort(
  91 |     |         bytes32[] memory array,
  92 |     |         function(bytes32, bytes32) pure returns (bool) comp
  93 |     |     ) internal pure returns (bytes32[] memory) {
  94 |     |         sort(_castToUint256Array(array), _castToUint256Comp(comp));
  95 |     |         return array;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.
 100 |     |      */
 101 |     |     function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {
 102 |     |         sort(_castToUint256Array(array), Comparators.lt);
 103 |     |         return array;
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops
 108 |     |      * at end (exclusive). Sorting follows the `comp` comparator.
 109 |     |      *
 110 |     |      * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.
 111 |     |      *
 112 |     |      * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should
 113 |     |      * be used only if the limits are within a memory array.
 114 |     |      */
 115 |     |     function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {
 116 |     |         unchecked {
 117 |     |             if (end - begin < 0x40) return;
 118 |     | 
 119 |     |             // Use first element as pivot
 120 |     |             uint256 pivot = _mload(begin);
 121 |     |             // Position where the pivot should be at the end of the loop
 122 |     |             uint256 pos = begin;
 123 |     | 
 124 |     |             for (uint256 it = begin + 0x20; it < end; it += 0x20) {
 125 |     |                 if (comp(_mload(it), pivot)) {
 126 |     |                     // If the value stored at the iterator's position comes before the pivot, we increment the
 127 |     |                     // position of the pivot and move the value there.
 128 |     |                     pos += 0x20;
 129 |     |                     _swap(pos, it);
 130 |     |                 }
 131 |     |             }
 132 |     | 
 133 |     |             _swap(begin, pos); // Swap pivot into place
 134 |     |             _quickSort(begin, pos, comp); // Sort the left side of the pivot
 135 |     |             _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot
 136 |     |         }
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Pointer to the memory location of the first element of `array`.
 141 |     |      */
 142 |     |     function _begin(uint256[] memory array) private pure returns (uint256 ptr) {
 143 |     |         assembly ("memory-safe") {
 144 |     |             ptr := add(array, 0x20)
 145 |     |         }
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word
 150 |     |      * that comes just after the last element of the array.
 151 |     |      */
 152 |     |     function _end(uint256[] memory array) private pure returns (uint256 ptr) {
 153 |     |         unchecked {
 154 |     |             return _begin(array) + array.length * 0x20;
 155 |     |         }
 156 |     |     }
 157 |     | 
 158 |     |     /**
 159 |     |      * @dev Load memory word (as a uint256) at location `ptr`.
 160 |     |      */
 161 |     |     function _mload(uint256 ptr) private pure returns (uint256 value) {
 162 |     |         assembly {
 163 |     |             value := mload(ptr)
 164 |     |         }
 165 |     |     }
 166 |     | 
 167 |     |     /**
 168 |     |      * @dev Swaps the elements memory location `ptr1` and `ptr2`.
 169 |     |      */
 170 |     |     function _swap(uint256 ptr1, uint256 ptr2) private pure {
 171 |     |         assembly {
 172 |     |             let value1 := mload(ptr1)
 173 |     |             let value2 := mload(ptr2)
 174 |     |             mstore(ptr1, value2)
 175 |     |             mstore(ptr2, value1)
 176 |     |         }
 177 |     |     }
 178 |     | 
 179 |     |     /// @dev Helper: low level cast address memory array to uint256 memory array
 180 |     |     function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {
 181 |     |         assembly {
 182 |     |             output := input
 183 |     |         }
 184 |     |     }
 185 |     | 
 186 |     |     /// @dev Helper: low level cast bytes32 memory array to uint256 memory array
 187 |     |     function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {
 188 |     |         assembly {
 189 |     |             output := input
 190 |     |         }
 191 |     |     }
 192 |     | 
 193 |     |     /// @dev Helper: low level cast address comp function to uint256 comp function
 194 |     |     function _castToUint256Comp(
 195 |     |         function(address, address) pure returns (bool) input
 196 |     |     ) private pure returns (function(uint256, uint256) pure returns (bool) output) {
 197 |     |         assembly {
 198 |     |             output := input
 199 |     |         }
 200 |     |     }
 201 |     | 
 202 |     |     /// @dev Helper: low level cast bytes32 comp function to uint256 comp function
 203 |     |     function _castToUint256Comp(
 204 |     |         function(bytes32, bytes32) pure returns (bool) input
 205 |     |     ) private pure returns (function(uint256, uint256) pure returns (bool) output) {
 206 |     |         assembly {
 207 |     |             output := input
 208 |     |         }
 209 |     |     }
 210 |     | 
 211 |     |     /**
 212 |     |      * @dev Searches a sorted `array` and returns the first index that contains
 213 |     |      * a value greater or equal to `element`. If no such index exists (i.e. all
 214 |     |      * values in the array are strictly less than `element`), the array length is
 215 |     |      * returned. Time complexity O(log n).
 216 |     |      *
 217 |     |      * NOTE: The `array` is expected to be sorted in ascending order, and to
 218 |     |      * contain no repeated elements.
 219 |     |      *
 220 |     |      * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks
 221 |     |      * support for repeated elements in the array. The {lowerBound} function should
 222 |     |      * be used instead.
 223 |     |      */
 224 | *   |     function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {
 225 | *   |         uint256 low = 0;
 226 | *   |         uint256 high = array.length;
 227 |     | 
 228 | *   |         if (high == 0) {
 229 | *   |             return 0;
 230 |     |         }
 231 |     | 
 232 | *   |         while (low < high) {
 233 | *   |             uint256 mid = Math.average(low, high);
 234 |     | 
 235 |     |             // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
 236 |     |             // because Math.average rounds towards zero (it does integer division with truncation).
 237 | *   |             if (unsafeAccess(array, mid).value > element) {
 238 |     |                 high = mid;
 239 |     |             } else {
 240 | *   |                 low = mid + 1;
 241 |     |             }
 242 |     |         }
 243 |     | 
 244 |     |         // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
 245 | *   |         if (low > 0 && unsafeAccess(array, low - 1).value == element) {
 246 | *   |             return low - 1;
 247 |     |         } else {
 248 | *   |             return low;
 249 |     |         }
 250 |     |     }
 251 |     | 
 252 |     |     /**
 253 |     |      * @dev Searches an `array` sorted in ascending order and returns the first
 254 |     |      * index that contains a value greater or equal than `element`. If no such index
 255 |     |      * exists (i.e. all values in the array are strictly less than `element`), the array
 256 |     |      * length is returned. Time complexity O(log n).
 257 |     |      *
 258 |     |      * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].
 259 |     |      */
 260 |     |     function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {
 261 |     |         uint256 low = 0;
 262 |     |         uint256 high = array.length;
 263 |     | 
 264 |     |         if (high == 0) {
 265 |     |             return 0;
 266 |     |         }
 267 |     | 
 268 |     |         while (low < high) {
 269 |     |             uint256 mid = Math.average(low, high);
 270 |     | 
 271 |     |             // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
 272 |     |             // because Math.average rounds towards zero (it does integer division with truncation).
 273 |     |             if (unsafeAccess(array, mid).value < element) {
 274 |     |                 // this cannot overflow because mid < high
 275 |     |                 unchecked {
 276 |     |                     low = mid + 1;
 277 |     |                 }
 278 |     |             } else {
 279 |     |                 high = mid;
 280 |     |             }
 281 |     |         }
 282 |     | 
 283 |     |         return low;
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Searches an `array` sorted in ascending order and returns the first
 288 |     |      * index that contains a value strictly greater than `element`. If no such index
 289 |     |      * exists (i.e. all values in the array are strictly less than `element`), the array
 290 |     |      * length is returned. Time complexity O(log n).
 291 |     |      *
 292 |     |      * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].
 293 |     |      */
 294 |     |     function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {
 295 |     |         uint256 low = 0;
 296 |     |         uint256 high = array.length;
 297 |     | 
 298 |     |         if (high == 0) {
 299 |     |             return 0;
 300 |     |         }
 301 |     | 
 302 |     |         while (low < high) {
 303 |     |             uint256 mid = Math.average(low, high);
 304 |     | 
 305 |     |             // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
 306 |     |             // because Math.average rounds towards zero (it does integer division with truncation).
 307 |     |             if (unsafeAccess(array, mid).value > element) {
 308 |     |                 high = mid;
 309 |     |             } else {
 310 |     |                 // this cannot overflow because mid < high
 311 |     |                 unchecked {
 312 |     |                     low = mid + 1;
 313 |     |                 }
 314 |     |             }
 315 |     |         }
 316 |     | 
 317 |     |         return low;
 318 |     |     }
 319 |     | 
 320 |     |     /**
 321 |     |      * @dev Same as {lowerBound}, but with an array in memory.
 322 |     |      */
 323 |     |     function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {
 324 |     |         uint256 low = 0;
 325 |     |         uint256 high = array.length;
 326 |     | 
 327 |     |         if (high == 0) {
 328 |     |             return 0;
 329 |     |         }
 330 |     | 
 331 |     |         while (low < high) {
 332 |     |             uint256 mid = Math.average(low, high);
 333 |     | 
 334 |     |             // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
 335 |     |             // because Math.average rounds towards zero (it does integer division with truncation).
 336 |     |             if (unsafeMemoryAccess(array, mid) < element) {
 337 |     |                 // this cannot overflow because mid < high
 338 |     |                 unchecked {
 339 |     |                     low = mid + 1;
 340 |     |                 }
 341 |     |             } else {
 342 |     |                 high = mid;
 343 |     |             }
 344 |     |         }
 345 |     | 
 346 |     |         return low;
 347 |     |     }
 348 |     | 
 349 |     |     /**
 350 |     |      * @dev Same as {upperBound}, but with an array in memory.
 351 |     |      */
 352 |     |     function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {
 353 |     |         uint256 low = 0;
 354 |     |         uint256 high = array.length;
 355 |     | 
 356 |     |         if (high == 0) {
 357 |     |             return 0;
 358 |     |         }
 359 |     | 
 360 |     |         while (low < high) {
 361 |     |             uint256 mid = Math.average(low, high);
 362 |     | 
 363 |     |             // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
 364 |     |             // because Math.average rounds towards zero (it does integer division with truncation).
 365 |     |             if (unsafeMemoryAccess(array, mid) > element) {
 366 |     |                 high = mid;
 367 |     |             } else {
 368 |     |                 // this cannot overflow because mid < high
 369 |     |                 unchecked {
 370 |     |                     low = mid + 1;
 371 |     |                 }
 372 |     |             }
 373 |     |         }
 374 |     | 
 375 |     |         return low;
 376 |     |     }
 377 |     | 
 378 |     |     /**
 379 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 380 |     |      *
 381 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 382 |     |      */
 383 |     |     function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {
 384 |     |         bytes32 slot;
 385 |     |         assembly ("memory-safe") {
 386 |     |             slot := arr.slot
 387 |     |         }
 388 |     |         return slot.deriveArray().offset(pos).getAddressSlot();
 389 |     |     }
 390 |     | 
 391 |     |     /**
 392 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 393 |     |      *
 394 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 395 |     |      */
 396 |     |     function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {
 397 |     |         bytes32 slot;
 398 |     |         assembly ("memory-safe") {
 399 |     |             slot := arr.slot
 400 |     |         }
 401 |     |         return slot.deriveArray().offset(pos).getBytes32Slot();
 402 |     |     }
 403 |     | 
 404 |     |     /**
 405 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 406 |     |      *
 407 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 408 |     |      */
 409 | *   |     function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {
 410 | *   |         bytes32 slot;
 411 |     |         assembly ("memory-safe") {
 412 | *   |             slot := arr.slot
 413 |     |         }
 414 | *   |         return slot.deriveArray().offset(pos).getUint256Slot();
 415 |     |     }
 416 |     | 
 417 |     |     /**
 418 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 419 |     |      *
 420 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 421 |     |      */
 422 |     |     function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {
 423 |     |         assembly {
 424 |     |             res := mload(add(add(arr, 0x20), mul(pos, 0x20)))
 425 |     |         }
 426 |     |     }
 427 |     | 
 428 |     |     /**
 429 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 430 |     |      *
 431 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 432 |     |      */
 433 |     |     function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {
 434 |     |         assembly {
 435 |     |             res := mload(add(add(arr, 0x20), mul(pos, 0x20)))
 436 |     |         }
 437 |     |     }
 438 |     | 
 439 |     |     /**
 440 |     |      * @dev Access an array in an "unsafe" way. Skips solidity "index-out-of-range" check.
 441 |     |      *
 442 |     |      * WARNING: Only use if you are certain `pos` is lower than the array length.
 443 |     |      */
 444 |     |     function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {
 445 |     |         assembly {
 446 |     |             res := mload(add(add(arr, 0x20), mul(pos, 0x20)))
 447 |     |         }
 448 |     |     }
 449 |     | 
 450 |     |     /**
 451 |     |      * @dev Helper to set the length of an dynamic array. Directly writing to `.length` is forbidden.
 452 |     |      *
 453 |     |      * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.
 454 |     |      */
 455 |     |     function unsafeSetLength(address[] storage array, uint256 len) internal {
 456 |     |         assembly ("memory-safe") {
 457 |     |             sstore(array.slot, len)
 458 |     |         }
 459 |     |     }
 460 |     | 
 461 |     |     /**
 462 |     |      * @dev Helper to set the length of an dynamic array. Directly writing to `.length` is forbidden.
 463 |     |      *
 464 |     |      * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.
 465 |     |      */
 466 |     |     function unsafeSetLength(bytes32[] storage array, uint256 len) internal {
 467 |     |         assembly ("memory-safe") {
 468 |     |             sstore(array.slot, len)
 469 |     |         }
 470 |     |     }
 471 |     | 
 472 |     |     /**
 473 |     |      * @dev Helper to set the length of an dynamic array. Directly writing to `.length` is forbidden.
 474 |     |      *
 475 |     |      * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.
 476 |     |      */
 477 |     |     function unsafeSetLength(uint256[] storage array, uint256 len) internal {
 478 |     |         assembly ("memory-safe") {
 479 |     |             sstore(array.slot, len)
 480 |     |         }
 481 |     |     }
 482 |     | }
 483 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/Comparators.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides a set of functions to compare values.
  8 |     |  *
  9 |     |  * _Available since v5.1._
 10 |     |  */
 11 |     | library Comparators {
 12 |     |     function lt(uint256 a, uint256 b) internal pure returns (bool) {
 13 |     |         return a < b;
 14 |     |     }
 15 |     | 
 16 |     |     function gt(uint256 a, uint256 b) internal pure returns (bool) {
 17 |     |         return a > b;
 18 |     |     }
 19 |     | }
 20 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @dev Provides information about the current execution context, including the
  7 |     |  * sender of the transaction and its data. While these are generally available
  8 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
  9 |     |  * manner, since when dealing with meta-transactions the account sending and
 10 |     |  * paying for execution may not be the actual sender (as far as an application
 11 |     |  * is concerned).
 12 |     |  *
 13 |     |  * This contract is only required for intermediate, library-like contracts.
 14 |     |  */
 15 |     | abstract contract Context {
 16 | *   |     function _msgSender() internal view virtual returns (address) {
 17 | *   |         return msg.sender;
 18 |     |     }
 19 |     | 
 20 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 21 |     |         return msg.data;
 22 |     |     }
 23 |     | }
 24 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/Counters.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @title Counters
  7 |     |  * @author Matt Condon (@shrugs)
  8 |     |  * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
  9 |     |  * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 10 |     |  *
 11 |     |  * Include with `using Counters for Counters.Counter;`
 12 |     |  */
 13 |     | library Counters {
 14 |     |     struct Counter {
 15 |     |         // This variable should never be directly accessed by users of the library: interactions must be restricted to
 16 |     |         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
 17 |     |         // this feature: see https://github.com/ethereum/solidity/issues/4637
 18 |     |         uint256 _value; // default: 0
 19 |     |     }
 20 |     | 
 21 | *   |     function current(Counter storage counter) internal view returns (uint256) {
 22 | *   |         return counter._value;
 23 |     |     }
 24 |     | 
 25 | *   |     function increment(Counter storage counter) internal {
 26 |     |         unchecked {
 27 | *   |             counter._value += 1;
 28 |     |         }
 29 |     |     }
 30 |     | 
 31 |     |     function decrement(Counter storage counter) internal {
 32 |     |         uint256 value = counter._value;
 33 |     |         require(value > 0, "Counter: decrement overflow");
 34 |     |         unchecked {
 35 |     |             counter._value = value - 1;
 36 |     |         }
 37 |     |     }
 38 |     | 
 39 |     |     function reset(Counter storage counter) internal {
 40 |     |         counter._value = 0;
 41 |     |     }
 42 |     | }
 43 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/Panic.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Helper library for emitting standardized panic codes.
  8 |     |  *
  9 |     |  * ```solidity
 10 |     |  * contract Example {
 11 |     |  *      using Panic for uint256;
 12 |     |  *
 13 |     |  *      // Use any of the declared internal constants
 14 |     |  *      function foo() { Panic.GENERIC.panic(); }
 15 |     |  *
 16 |     |  *      // Alternatively
 17 |     |  *      function foo() { Panic.panic(Panic.GENERIC); }
 18 |     |  * }
 19 |     |  * ```
 20 |     |  *
 21 |     |  * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].
 22 |     |  *
 23 |     |  * _Available since v5.1._
 24 |     |  */
 25 |     | // slither-disable-next-line unused-state
 26 |     | library Panic {
 27 |     |     /// @dev generic / unspecified error
 28 |     |     uint256 internal constant GENERIC = 0x00;
 29 |     |     /// @dev used by the assert() builtin
 30 |     |     uint256 internal constant ASSERT = 0x01;
 31 |     |     /// @dev arithmetic underflow or overflow
 32 |     |     uint256 internal constant UNDER_OVERFLOW = 0x11;
 33 |     |     /// @dev division or modulo by zero
 34 |     |     uint256 internal constant DIVISION_BY_ZERO = 0x12;
 35 |     |     /// @dev enum conversion error
 36 |     |     uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;
 37 |     |     /// @dev invalid encoding in storage
 38 |     |     uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;
 39 |     |     /// @dev empty array pop
 40 |     |     uint256 internal constant EMPTY_ARRAY_POP = 0x31;
 41 |     |     /// @dev array out of bounds access
 42 |     |     uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;
 43 |     |     /// @dev resource error (too large allocation or too large array)
 44 |     |     uint256 internal constant RESOURCE_ERROR = 0x41;
 45 |     |     /// @dev calling invalid internal function
 46 |     |     uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;
 47 |     | 
 48 |     |     /// @dev Reverts with a panic code. Recommended to use with
 49 |     |     /// the internal constants with predefined codes.
 50 |     |     function panic(uint256 code) internal pure {
 51 |     |         assembly ("memory-safe") {
 52 |     |             mstore(0x00, 0x4e487b71)
 53 |     |             mstore(0x20, code)
 54 |     |             revert(0x1c, 0x24)
 55 |     |         }
 56 |     |     }
 57 |     | }
 58 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  7 |     |  *
  8 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
  9 |     |  * available, which can be applied to functions to make sure there are no nested
 10 |     |  * (reentrant) calls to them.
 11 |     |  *
 12 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 13 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 14 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 15 |     |  * points to them.
 16 |     |  *
 17 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 18 |     |  * to protect against it, check out our blog post
 19 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 20 |     |  */
 21 |     | abstract contract ReentrancyGuard {
 22 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 23 |     |     // word because each write operation emits an extra SLOAD to first read the
 24 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 25 |     |     // back. This is the compiler's defense against contract upgrades and
 26 |     |     // pointer aliasing, and it cannot be disabled.
 27 |     | 
 28 |     |     // The values being non-zero value makes deployment a bit more expensive,
 29 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 30 |     |     // amount. Since refunds are capped to a percentage of the total
 31 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 32 |     |     // increase the likelihood of the full refund coming into effect.
 33 | *   |     uint256 private constant _NOT_ENTERED = 1;
 34 | *   |     uint256 private constant _ENTERED = 2;
 35 |     | 
 36 |     |     uint256 private _status;
 37 |     | 
 38 |     |     constructor() {
 39 | *   |         _status = _NOT_ENTERED;
 40 |     |     }
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 44 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 45 |     |      * function is not supported. It is possible to prevent this from happening
 46 |     |      * by making the `nonReentrant` function external, and make it call a
 47 |     |      * `private` function that does the actual work.
 48 |     |      */
 49 |     |     modifier nonReentrant() {
 50 |     |         // On the first call to nonReentrant, _notEntered will be true
 51 | *   |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
 52 |     | 
 53 |     |         // Any calls to nonReentrant after this point will fail
 54 | *   |         _status = _ENTERED;
 55 |     | 
 56 |     |         _;
 57 |     | 
 58 |     |         // By storing the original value once again, a refund is triggered (see
 59 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 60 | *   |         _status = _NOT_ENTERED;
 61 |     |     }
 62 |     | }
 63 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/SlotDerivation.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/SlotDerivation.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots
   9 |     |  * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by
  10 |     |  * the solidity language / compiler.
  11 |     |  *
  12 |     |  * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].
  13 |     |  *
  14 |     |  * Example usage:
  15 |     |  * ```solidity
  16 |     |  * contract Example {
  17 |     |  *     // Add the library methods
  18 |     |  *     using StorageSlot for bytes32;
  19 |     |  *     using SlotDerivation for bytes32;
  20 |     |  *
  21 |     |  *     // Declare a namespace
  22 |     |  *     string private constant _NAMESPACE = "<namespace>" // eg. OpenZeppelin.Slot
  23 |     |  *
  24 |     |  *     function setValueInNamespace(uint256 key, address newValue) internal {
  25 |     |  *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;
  26 |     |  *     }
  27 |     |  *
  28 |     |  *     function getValueInNamespace(uint256 key) internal view returns (address) {
  29 |     |  *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;
  30 |     |  *     }
  31 |     |  * }
  32 |     |  * ```
  33 |     |  *
  34 |     |  * TIP: Consider using this library along with {StorageSlot}.
  35 |     |  *
  36 |     |  * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking
  37 |     |  * upgrade safety will ignore the slots accessed through this library.
  38 |     |  *
  39 |     |  * _Available since v5.1._
  40 |     |  */
  41 |     | library SlotDerivation {
  42 |     |     /**
  43 |     |      * @dev Derive an ERC-7201 slot from a string (namespace).
  44 |     |      */
  45 |     |     function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {
  46 |     |         assembly ("memory-safe") {
  47 |     |             mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))
  48 |     |             slot := and(keccak256(0x00, 0x20), not(0xff))
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Add an offset to a slot to get the n-th element of a structure or an array.
  54 |     |      */
  55 | *   |     function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {
  56 |     |         unchecked {
  57 | *   |             return bytes32(uint256(slot) + pos);
  58 |     |         }
  59 |     |     }
  60 |     | 
  61 |     |     /**
  62 |     |      * @dev Derive the location of the first element in an array from the slot where the length is stored.
  63 |     |      */
  64 | *   |     function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {
  65 |     |         assembly ("memory-safe") {
  66 | *   |             mstore(0x00, slot)
  67 | *   |             result := keccak256(0x00, 0x20)
  68 |     |         }
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Derive the location of a mapping element from the key.
  73 |     |      */
  74 |     |     function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {
  75 |     |         assembly ("memory-safe") {
  76 |     |             mstore(0x00, and(key, shr(96, not(0))))
  77 |     |             mstore(0x20, slot)
  78 |     |             result := keccak256(0x00, 0x40)
  79 |     |         }
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @dev Derive the location of a mapping element from the key.
  84 |     |      */
  85 |     |     function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {
  86 |     |         assembly ("memory-safe") {
  87 |     |             mstore(0x00, iszero(iszero(key)))
  88 |     |             mstore(0x20, slot)
  89 |     |             result := keccak256(0x00, 0x40)
  90 |     |         }
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Derive the location of a mapping element from the key.
  95 |     |      */
  96 |     |     function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {
  97 |     |         assembly ("memory-safe") {
  98 |     |             mstore(0x00, key)
  99 |     |             mstore(0x20, slot)
 100 |     |             result := keccak256(0x00, 0x40)
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     /**
 105 |     |      * @dev Derive the location of a mapping element from the key.
 106 |     |      */
 107 |     |     function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {
 108 |     |         assembly ("memory-safe") {
 109 |     |             mstore(0x00, key)
 110 |     |             mstore(0x20, slot)
 111 |     |             result := keccak256(0x00, 0x40)
 112 |     |         }
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev Derive the location of a mapping element from the key.
 117 |     |      */
 118 |     |     function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {
 119 |     |         assembly ("memory-safe") {
 120 |     |             mstore(0x00, key)
 121 |     |             mstore(0x20, slot)
 122 |     |             result := keccak256(0x00, 0x40)
 123 |     |         }
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Derive the location of a mapping element from the key.
 128 |     |      */
 129 |     |     function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {
 130 |     |         assembly ("memory-safe") {
 131 |     |             let length := mload(key)
 132 |     |             let begin := add(key, 0x20)
 133 |     |             let end := add(begin, length)
 134 |     |             let cache := mload(end)
 135 |     |             mstore(end, slot)
 136 |     |             result := keccak256(begin, add(length, 0x20))
 137 |     |             mstore(end, cache)
 138 |     |         }
 139 |     |     }
 140 |     | 
 141 |     |     /**
 142 |     |      * @dev Derive the location of a mapping element from the key.
 143 |     |      */
 144 |     |     function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {
 145 |     |         assembly ("memory-safe") {
 146 |     |             let length := mload(key)
 147 |     |             let begin := add(key, 0x20)
 148 |     |             let end := add(begin, length)
 149 |     |             let cache := mload(end)
 150 |     |             mstore(end, slot)
 151 |     |             result := keccak256(begin, add(length, 0x20))
 152 |     |             mstore(end, cache)
 153 |     |         }
 154 |     |     }
 155 |     | }
 156 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/StorageSlot.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.20;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for reading and writing primitive types to specific storage slots.
   9 |     |  *
  10 |     |  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
  11 |     |  * This library helps with reading and writing to such slots without the need for inline assembly.
  12 |     |  *
  13 |     |  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
  14 |     |  *
  15 |     |  * Example usage to set ERC-1967 implementation slot:
  16 |     |  * ```solidity
  17 |     |  * contract ERC1967 {
  18 |     |  *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.
  19 |     |  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  20 |     |  *
  21 |     |  *     function _getImplementation() internal view returns (address) {
  22 |     |  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
  23 |     |  *     }
  24 |     |  *
  25 |     |  *     function _setImplementation(address newImplementation) internal {
  26 |     |  *         require(newImplementation.code.length > 0);
  27 |     |  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
  28 |     |  *     }
  29 |     |  * }
  30 |     |  * ```
  31 |     |  *
  32 |     |  * TIP: Consider using this library along with {SlotDerivation}.
  33 |     |  */
  34 |     | library StorageSlot {
  35 |     |     struct AddressSlot {
  36 |     |         address value;
  37 |     |     }
  38 |     | 
  39 |     |     struct BooleanSlot {
  40 |     |         bool value;
  41 |     |     }
  42 |     | 
  43 |     |     struct Bytes32Slot {
  44 |     |         bytes32 value;
  45 |     |     }
  46 |     | 
  47 |     |     struct Uint256Slot {
  48 |     |         uint256 value;
  49 |     |     }
  50 |     | 
  51 |     |     struct Int256Slot {
  52 |     |         int256 value;
  53 |     |     }
  54 |     | 
  55 |     |     struct StringSlot {
  56 |     |         string value;
  57 |     |     }
  58 |     | 
  59 |     |     struct BytesSlot {
  60 |     |         bytes value;
  61 |     |     }
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
  65 |     |      */
  66 |     |     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
  67 |     |         assembly ("memory-safe") {
  68 |     |             r.slot := slot
  69 |     |         }
  70 |     |     }
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Returns a `BooleanSlot` with member `value` located at `slot`.
  74 |     |      */
  75 |     |     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
  76 |     |         assembly ("memory-safe") {
  77 |     |             r.slot := slot
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     /**
  82 |     |      * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.
  83 |     |      */
  84 |     |     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
  85 |     |         assembly ("memory-safe") {
  86 |     |             r.slot := slot
  87 |     |         }
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Returns a `Uint256Slot` with member `value` located at `slot`.
  92 |     |      */
  93 | *   |     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
  94 |     |         assembly ("memory-safe") {
  95 | *   |             r.slot := slot
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Returns a `Int256Slot` with member `value` located at `slot`.
 101 |     |      */
 102 |     |     function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {
 103 |     |         assembly ("memory-safe") {
 104 |     |             r.slot := slot
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     /**
 109 |     |      * @dev Returns a `StringSlot` with member `value` located at `slot`.
 110 |     |      */
 111 |     |     function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {
 112 |     |         assembly ("memory-safe") {
 113 |     |             r.slot := slot
 114 |     |         }
 115 |     |     }
 116 |     | 
 117 |     |     /**
 118 |     |      * @dev Returns an `StringSlot` representation of the string storage pointer `store`.
 119 |     |      */
 120 |     |     function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {
 121 |     |         assembly ("memory-safe") {
 122 |     |             r.slot := store.slot
 123 |     |         }
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Returns a `BytesSlot` with member `value` located at `slot`.
 128 |     |      */
 129 |     |     function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {
 130 |     |         assembly ("memory-safe") {
 131 |     |             r.slot := slot
 132 |     |         }
 133 |     |     }
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.
 137 |     |      */
 138 |     |     function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {
 139 |     |         assembly ("memory-safe") {
 140 |     |             r.slot := store.slot
 141 |     |         }
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/Strings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @dev String operations.
  7 |     |  */
  8 |     | library Strings {
  9 |     |     bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";
 10 |     | 
 11 |     |     /**
 12 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 13 |     |      */
 14 |     |     function toString(uint256 value) internal pure returns (string memory) {
 15 |     |         // Inspired by OraclizeAPI's implementation - MIT licence
 16 |     |         // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol
 17 |     | 
 18 |     |         if (value == 0) {
 19 |     |             return "0";
 20 |     |         }
 21 |     |         uint256 temp = value;
 22 |     |         uint256 digits;
 23 |     |         while (temp != 0) {
 24 |     |             digits++;
 25 |     |             temp /= 10;
 26 |     |         }
 27 |     |         bytes memory buffer = new bytes(digits);
 28 |     |         while (value != 0) {
 29 |     |             digits -= 1;
 30 |     |             buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
 31 |     |             value /= 10;
 32 |     |         }
 33 |     |         return string(buffer);
 34 |     |     }
 35 |     | 
 36 |     |     /**
 37 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 38 |     |      */
 39 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 40 |     |         if (value == 0) {
 41 |     |             return "0x00";
 42 |     |         }
 43 |     |         uint256 temp = value;
 44 |     |         uint256 length = 0;
 45 |     |         while (temp != 0) {
 46 |     |             length++;
 47 |     |             temp >>= 8;
 48 |     |         }
 49 |     |         return toHexString(value, length);
 50 |     |     }
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 54 |     |      */
 55 | *   |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 56 | *   |         bytes memory buffer = new bytes(2 * length + 2);
 57 | *   |         buffer[0] = "0";
 58 | *   |         buffer[1] = "x";
 59 | *   |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 60 | *   |             buffer[i] = _HEX_SYMBOLS[value & 0xf];
 61 | *   |             value >>= 4;
 62 |     |         }
 63 | *   |         require(value == 0, "Strings: hex length insufficient");
 64 | *   |         return string(buffer);
 65 |     |     }
 66 |     | }
 67 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import "./IERC165.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Implementation of the {IERC165} interface.
  9 |     |  *
 10 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 11 |     |  * for the additional interface id that will be supported. For example:
 12 |     |  *
 13 |     |  * ```solidity
 14 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 15 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 16 |     |  * }
 17 |     |  * ```
 18 |     |  *
 19 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 20 |     |  */
 21 |     | abstract contract ERC165 is IERC165 {
 22 |     |     /**
 23 |     |      * @dev See {IERC165-supportsInterface}.
 24 |     |      */
 25 | *   |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 26 | *   |         return interfaceId == type(IERC165).interfaceId;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | /**
  6 |     |  * @dev Interface of the ERC165 standard, as defined in the
  7 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  8 |     |  *
  9 |     |  * Implementers can declare support of contract interfaces, which can then be
 10 |     |  * queried by others ({ERC165Checker}).
 11 |     |  *
 12 |     |  * For an implementation, see {ERC165}.
 13 |     |  */
 14 |     | interface IERC165 {
 15 |     |     /**
 16 |     |      * @dev Returns true if this contract implements the interface defined by
 17 |     |      * `interfaceId`. See the corresponding
 18 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 19 |     |      * to learn more about how these ids are created.
 20 |     |      *
 21 |     |      * This function call must use less than 30 000 gas.
 22 |     |      */
 23 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 24 |     | }
 25 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {Panic} from "../Panic.sol";
   7 |     | import {SafeCast} from "./SafeCast.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Standard math utilities missing in the Solidity language.
  11 |     |  */
  12 |     | library Math {
  13 |     |     enum Rounding {
  14 |     |         Floor, // Toward negative infinity
  15 |     |         Ceil, // Toward positive infinity
  16 |     |         Trunc, // Toward zero
  17 |     |         Expand // Away from zero
  18 |     |     }
  19 |     | 
  20 |     |     /**
  21 |     |      * @dev Returns the addition of two unsigned integers, with an success flag (no overflow).
  22 |     |      */
  23 |     |     function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  24 |     |         unchecked {
  25 |     |             uint256 c = a + b;
  26 |     |             if (c < a) return (false, 0);
  27 |     |             return (true, c);
  28 |     |         }
  29 |     |     }
  30 |     | 
  31 |     |     /**
  32 |     |      * @dev Returns the subtraction of two unsigned integers, with an success flag (no overflow).
  33 |     |      */
  34 |     |     function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  35 |     |         unchecked {
  36 |     |             if (b > a) return (false, 0);
  37 |     |             return (true, a - b);
  38 |     |         }
  39 |     |     }
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Returns the multiplication of two unsigned integers, with an success flag (no overflow).
  43 |     |      */
  44 |     |     function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  45 |     |         unchecked {
  46 |     |             // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
  47 |     |             // benefit is lost if 'b' is also tested.
  48 |     |             // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
  49 |     |             if (a == 0) return (true, 0);
  50 |     |             uint256 c = a * b;
  51 |     |             if (c / a != b) return (false, 0);
  52 |     |             return (true, c);
  53 |     |         }
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).
  58 |     |      */
  59 |     |     function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  60 |     |         unchecked {
  61 |     |             if (b == 0) return (false, 0);
  62 |     |             return (true, a / b);
  63 |     |         }
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).
  68 |     |      */
  69 |     |     function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {
  70 |     |         unchecked {
  71 |     |             if (b == 0) return (false, 0);
  72 |     |             return (true, a % b);
  73 |     |         }
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.
  78 |     |      *
  79 |     |      * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.
  80 |     |      * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute
  81 |     |      * one branch when needed, making this function more expensive.
  82 |     |      */
  83 |     |     function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {
  84 |     |         unchecked {
  85 |     |             // branchless ternary works because:
  86 |     |             // b ^ (a ^ b) == a
  87 |     |             // b ^ 0 == b
  88 |     |             return b ^ ((a ^ b) * SafeCast.toUint(condition));
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Returns the largest of two numbers.
  94 |     |      */
  95 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  96 |     |         return ternary(a > b, a, b);
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Returns the smallest of two numbers.
 101 |     |      */
 102 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
 103 |     |         return ternary(a < b, a, b);
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @dev Returns the average of two numbers. The result is rounded towards
 108 |     |      * zero.
 109 |     |      */
 110 | *   |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
 111 |     |         // (a + b) / 2 can overflow.
 112 | *   |         return (a & b) + (a ^ b) / 2;
 113 |     |     }
 114 |     | 
 115 |     |     /**
 116 |     |      * @dev Returns the ceiling of the division of two numbers.
 117 |     |      *
 118 |     |      * This differs from standard division with `/` in that it rounds towards infinity instead
 119 |     |      * of rounding towards zero.
 120 |     |      */
 121 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
 122 |     |         if (b == 0) {
 123 |     |             // Guarantee the same behavior as in a regular Solidity division.
 124 |     |             Panic.panic(Panic.DIVISION_BY_ZERO);
 125 |     |         }
 126 |     | 
 127 |     |         // The following calculation ensures accurate ceiling division without overflow.
 128 |     |         // Since a is non-zero, (a - 1) / b will not overflow.
 129 |     |         // The largest possible result occurs when (a - 1) / b is type(uint256).max,
 130 |     |         // but the largest value we can obtain is type(uint256).max - 1, which happens
 131 |     |         // when a = type(uint256).max and b = 1.
 132 |     |         unchecked {
 133 |     |             return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);
 134 |     |         }
 135 |     |     }
 136 |     | 
 137 |     |     /**
 138 |     |      * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or
 139 |     |      * denominator == 0.
 140 |     |      *
 141 |     |      * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by
 142 |     |      * Uniswap Labs also under MIT license.
 143 |     |      */
 144 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
 145 |     |         unchecked {
 146 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2 and mod 2 - 1, then use
 147 |     |             // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
 148 |     |             // variables such that product = prod1 * 2 + prod0.
 149 |     |             uint256 prod0 = x * y; // Least significant 256 bits of the product
 150 |     |             uint256 prod1; // Most significant 256 bits of the product
 151 |     |             assembly {
 152 |     |                 let mm := mulmod(x, y, not(0))
 153 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
 154 |     |             }
 155 |     | 
 156 |     |             // Handle non-overflow cases, 256 by 256 division.
 157 |     |             if (prod1 == 0) {
 158 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
 159 |     |                 // The surrounding unchecked block does not change this fact.
 160 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
 161 |     |                 return prod0 / denominator;
 162 |     |             }
 163 |     | 
 164 |     |             // Make sure the result is less than 2. Also prevents denominator == 0.
 165 |     |             if (denominator <= prod1) {
 166 |     |                 Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));
 167 |     |             }
 168 |     | 
 169 |     |             ///////////////////////////////////////////////
 170 |     |             // 512 by 256 division.
 171 |     |             ///////////////////////////////////////////////
 172 |     | 
 173 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
 174 |     |             uint256 remainder;
 175 |     |             assembly {
 176 |     |                 // Compute remainder using mulmod.
 177 |     |                 remainder := mulmod(x, y, denominator)
 178 |     | 
 179 |     |                 // Subtract 256 bit number from 512 bit number.
 180 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
 181 |     |                 prod0 := sub(prod0, remainder)
 182 |     |             }
 183 |     | 
 184 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator.
 185 |     |             // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.
 186 |     | 
 187 |     |             uint256 twos = denominator & (0 - denominator);
 188 |     |             assembly {
 189 |     |                 // Divide denominator by twos.
 190 |     |                 denominator := div(denominator, twos)
 191 |     | 
 192 |     |                 // Divide [prod1 prod0] by twos.
 193 |     |                 prod0 := div(prod0, twos)
 194 |     | 
 195 |     |                 // Flip twos such that it is 2 / twos. If twos is zero, then it becomes one.
 196 |     |                 twos := add(div(sub(0, twos), twos), 1)
 197 |     |             }
 198 |     | 
 199 |     |             // Shift in bits from prod1 into prod0.
 200 |     |             prod0 |= prod1 * twos;
 201 |     | 
 202 |     |             // Invert denominator mod 2. Now that denominator is an odd number, it has an inverse modulo 2 such
 203 |     |             // that denominator * inv  1 mod 2. Compute the inverse by starting with a seed that is correct for
 204 |     |             // four bits. That is, denominator * inv  1 mod 2.
 205 |     |             uint256 inverse = (3 * denominator) ^ 2;
 206 |     | 
 207 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also
 208 |     |             // works in modular arithmetic, doubling the correct bits in each step.
 209 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 210 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 211 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 212 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 213 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 214 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2
 215 |     | 
 216 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 217 |     |             // This will give us the correct result modulo 2. Since the preconditions guarantee that the outcome is
 218 |     |             // less than 2, this is the final result. We don't need to compute the high bits of the result and prod1
 219 |     |             // is no longer required.
 220 |     |             result = prod0 * inverse;
 221 |     |             return result;
 222 |     |         }
 223 |     |     }
 224 |     | 
 225 |     |     /**
 226 |     |      * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.
 227 |     |      */
 228 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 229 |     |         return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);
 230 |     |     }
 231 |     | 
 232 |     |     /**
 233 |     |      * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.
 234 |     |      *
 235 |     |      * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.
 236 |     |      * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.
 237 |     |      *
 238 |     |      * If the input value is not inversible, 0 is returned.
 239 |     |      *
 240 |     |      * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the
 241 |     |      * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.
 242 |     |      */
 243 |     |     function invMod(uint256 a, uint256 n) internal pure returns (uint256) {
 244 |     |         unchecked {
 245 |     |             if (n == 0) return 0;
 246 |     | 
 247 |     |             // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)
 248 |     |             // Used to compute integers x and y such that: ax + ny = gcd(a, n).
 249 |     |             // When the gcd is 1, then the inverse of a modulo n exists and it's x.
 250 |     |             // ax + ny = 1
 251 |     |             // ax = 1 + (-y)n
 252 |     |             // ax  1 (mod n) # x is the inverse of a modulo n
 253 |     | 
 254 |     |             // If the remainder is 0 the gcd is n right away.
 255 |     |             uint256 remainder = a % n;
 256 |     |             uint256 gcd = n;
 257 |     | 
 258 |     |             // Therefore the initial coefficients are:
 259 |     |             // ax + ny = gcd(a, n) = n
 260 |     |             // 0a + 1n = n
 261 |     |             int256 x = 0;
 262 |     |             int256 y = 1;
 263 |     | 
 264 |     |             while (remainder != 0) {
 265 |     |                 uint256 quotient = gcd / remainder;
 266 |     | 
 267 |     |                 (gcd, remainder) = (
 268 |     |                     // The old remainder is the next gcd to try.
 269 |     |                     remainder,
 270 |     |                     // Compute the next remainder.
 271 |     |                     // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd
 272 |     |                     // where gcd is at most n (capped to type(uint256).max)
 273 |     |                     gcd - remainder * quotient
 274 |     |                 );
 275 |     | 
 276 |     |                 (x, y) = (
 277 |     |                     // Increment the coefficient of a.
 278 |     |                     y,
 279 |     |                     // Decrement the coefficient of n.
 280 |     |                     // Can overflow, but the result is casted to uint256 so that the
 281 |     |                     // next value of y is "wrapped around" to a value between 0 and n - 1.
 282 |     |                     x - y * int256(quotient)
 283 |     |                 );
 284 |     |             }
 285 |     | 
 286 |     |             if (gcd != 1) return 0; // No inverse exists.
 287 |     |             return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.
 288 |     |         }
 289 |     |     }
 290 |     | 
 291 |     |     /**
 292 |     |      * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.
 293 |     |      *
 294 |     |      * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is
 295 |     |      * prime, then `a**(p-1)  1 mod p`. As a consequence, we have `a * a**(p-2)  1 mod p`, which means that
 296 |     |      * `a**(p-2)` is the modular multiplicative inverse of a in Fp.
 297 |     |      *
 298 |     |      * NOTE: this function does NOT check that `p` is a prime greater than `2`.
 299 |     |      */
 300 |     |     function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {
 301 |     |         unchecked {
 302 |     |             return Math.modExp(a, p - 2, p);
 303 |     |         }
 304 |     |     }
 305 |     | 
 306 |     |     /**
 307 |     |      * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)
 308 |     |      *
 309 |     |      * Requirements:
 310 |     |      * - modulus can't be zero
 311 |     |      * - underlying staticcall to precompile must succeed
 312 |     |      *
 313 |     |      * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make
 314 |     |      * sure the chain you're using it on supports the precompiled contract for modular exponentiation
 315 |     |      * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,
 316 |     |      * the underlying function will succeed given the lack of a revert, but the result may be incorrectly
 317 |     |      * interpreted as 0.
 318 |     |      */
 319 |     |     function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {
 320 |     |         (bool success, uint256 result) = tryModExp(b, e, m);
 321 |     |         if (!success) {
 322 |     |             Panic.panic(Panic.DIVISION_BY_ZERO);
 323 |     |         }
 324 |     |         return result;
 325 |     |     }
 326 |     | 
 327 |     |     /**
 328 |     |      * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).
 329 |     |      * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying
 330 |     |      * to operate modulo 0 or if the underlying precompile reverted.
 331 |     |      *
 332 |     |      * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain
 333 |     |      * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in
 334 |     |      * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack
 335 |     |      * of a revert, but the result may be incorrectly interpreted as 0.
 336 |     |      */
 337 |     |     function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {
 338 |     |         if (m == 0) return (false, 0);
 339 |     |         assembly ("memory-safe") {
 340 |     |             let ptr := mload(0x40)
 341 |     |             // | Offset    | Content    | Content (Hex)                                                      |
 342 |     |             // |-----------|------------|--------------------------------------------------------------------|
 343 |     |             // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |
 344 |     |             // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |
 345 |     |             // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |
 346 |     |             // | 0x60:0x7f | value of b | 0x<.............................................................b> |
 347 |     |             // | 0x80:0x9f | value of e | 0x<.............................................................e> |
 348 |     |             // | 0xa0:0xbf | value of m | 0x<.............................................................m> |
 349 |     |             mstore(ptr, 0x20)
 350 |     |             mstore(add(ptr, 0x20), 0x20)
 351 |     |             mstore(add(ptr, 0x40), 0x20)
 352 |     |             mstore(add(ptr, 0x60), b)
 353 |     |             mstore(add(ptr, 0x80), e)
 354 |     |             mstore(add(ptr, 0xa0), m)
 355 |     | 
 356 |     |             // Given the result < m, it's guaranteed to fit in 32 bytes,
 357 |     |             // so we can use the memory scratch space located at offset 0.
 358 |     |             success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)
 359 |     |             result := mload(0x00)
 360 |     |         }
 361 |     |     }
 362 |     | 
 363 |     |     /**
 364 |     |      * @dev Variant of {modExp} that supports inputs of arbitrary length.
 365 |     |      */
 366 |     |     function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {
 367 |     |         (bool success, bytes memory result) = tryModExp(b, e, m);
 368 |     |         if (!success) {
 369 |     |             Panic.panic(Panic.DIVISION_BY_ZERO);
 370 |     |         }
 371 |     |         return result;
 372 |     |     }
 373 |     | 
 374 |     |     /**
 375 |     |      * @dev Variant of {tryModExp} that supports inputs of arbitrary length.
 376 |     |      */
 377 |     |     function tryModExp(
 378 |     |         bytes memory b,
 379 |     |         bytes memory e,
 380 |     |         bytes memory m
 381 |     |     ) internal view returns (bool success, bytes memory result) {
 382 |     |         if (_zeroBytes(m)) return (false, new bytes(0));
 383 |     | 
 384 |     |         uint256 mLen = m.length;
 385 |     | 
 386 |     |         // Encode call args in result and move the free memory pointer
 387 |     |         result = abi.encodePacked(b.length, e.length, mLen, b, e, m);
 388 |     | 
 389 |     |         assembly ("memory-safe") {
 390 |     |             let dataPtr := add(result, 0x20)
 391 |     |             // Write result on top of args to avoid allocating extra memory.
 392 |     |             success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)
 393 |     |             // Overwrite the length.
 394 |     |             // result.length > returndatasize() is guaranteed because returndatasize() == m.length
 395 |     |             mstore(result, mLen)
 396 |     |             // Set the memory pointer after the returned data.
 397 |     |             mstore(0x40, add(dataPtr, mLen))
 398 |     |         }
 399 |     |     }
 400 |     | 
 401 |     |     /**
 402 |     |      * @dev Returns whether the provided byte array is zero.
 403 |     |      */
 404 |     |     function _zeroBytes(bytes memory byteArray) private pure returns (bool) {
 405 |     |         for (uint256 i = 0; i < byteArray.length; ++i) {
 406 |     |             if (byteArray[i] != 0) {
 407 |     |                 return false;
 408 |     |             }
 409 |     |         }
 410 |     |         return true;
 411 |     |     }
 412 |     | 
 413 |     |     /**
 414 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded
 415 |     |      * towards zero.
 416 |     |      *
 417 |     |      * This method is based on Newton's method for computing square roots; the algorithm is restricted to only
 418 |     |      * using integer operations.
 419 |     |      */
 420 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 421 |     |         unchecked {
 422 |     |             // Take care of easy edge cases when a == 0 or a == 1
 423 |     |             if (a <= 1) {
 424 |     |                 return a;
 425 |     |             }
 426 |     | 
 427 |     |             // In this function, we use Newton's method to get a root of `f(x) := x - a`. It involves building a
 428 |     |             // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between
 429 |     |             // the current value as `_n = | x_n - sqrt(a) |`.
 430 |     |             //
 431 |     |             // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root
 432 |     |             // of the target. (i.e. `2**(e-1)  sqrt(a) < 2**e`). We know that `e  128` because `(2) = 2` is
 433 |     |             // bigger than any uint256.
 434 |     |             //
 435 |     |             // By noticing that
 436 |     |             // `2**(e-1)  sqrt(a) < 2**e  (2**(e-1))  a < (2**e)  2**(2*e-2)  a < 2**(2*e)`
 437 |     |             // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar
 438 |     |             // to the msb function.
 439 |     |             uint256 aa = a;
 440 |     |             uint256 xn = 1;
 441 |     | 
 442 |     |             if (aa >= (1 << 128)) {
 443 |     |                 aa >>= 128;
 444 |     |                 xn <<= 64;
 445 |     |             }
 446 |     |             if (aa >= (1 << 64)) {
 447 |     |                 aa >>= 64;
 448 |     |                 xn <<= 32;
 449 |     |             }
 450 |     |             if (aa >= (1 << 32)) {
 451 |     |                 aa >>= 32;
 452 |     |                 xn <<= 16;
 453 |     |             }
 454 |     |             if (aa >= (1 << 16)) {
 455 |     |                 aa >>= 16;
 456 |     |                 xn <<= 8;
 457 |     |             }
 458 |     |             if (aa >= (1 << 8)) {
 459 |     |                 aa >>= 8;
 460 |     |                 xn <<= 4;
 461 |     |             }
 462 |     |             if (aa >= (1 << 4)) {
 463 |     |                 aa >>= 4;
 464 |     |                 xn <<= 2;
 465 |     |             }
 466 |     |             if (aa >= (1 << 2)) {
 467 |     |                 xn <<= 1;
 468 |     |             }
 469 |     | 
 470 |     |             // We now have x_n such that `x_n = 2**(e-1)  sqrt(a) < 2**e = 2 * x_n`. This implies _n  2**(e-1).
 471 |     |             //
 472 |     |             // We can refine our estimation by noticing that the middle of that interval minimizes the error.
 473 |     |             // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to _n  2**(e-2).
 474 |     |             // This is going to be our x_0 (and _0)
 475 |     |             xn = (3 * xn) >> 1; // _0 := | x_0 - sqrt(a) |  2**(e-2)
 476 |     | 
 477 |     |             // From here, Newton's method give us:
 478 |     |             // x_{n+1} = (x_n + a / x_n) / 2
 479 |     |             //
 480 |     |             // One should note that:
 481 |     |             // x_{n+1} - a = ((x_n + a / x_n) / 2) - a
 482 |     |             //              = ((x_n + a) / (2 * x_n)) - a
 483 |     |             //              = (x_n + 2 * a * x_n + a) / (4 * x_n) - a
 484 |     |             //              = (x_n + 2 * a * x_n + a - 4 * a * x_n) / (4 * x_n)
 485 |     |             //              = (x_n - 2 * a * x_n + a) / (4 * x_n)
 486 |     |             //              = (x_n - a) / (2 * x_n)
 487 |     |             //              = ((x_n - a) / (2 * x_n))
 488 |     |             //               0
 489 |     |             // Which proves that for all n  1, sqrt(a)  x_n
 490 |     |             //
 491 |     |             // This gives us the proof of quadratic convergence of the sequence:
 492 |     |             // _{n+1} = | x_{n+1} - sqrt(a) |
 493 |     |             //         = | (x_n + a / x_n) / 2 - sqrt(a) |
 494 |     |             //         = | (x_n + a - 2*x_n*sqrt(a)) / (2 * x_n) |
 495 |     |             //         = | (x_n - sqrt(a)) / (2 * x_n) |
 496 |     |             //         = | _n / (2 * x_n) |
 497 |     |             //         = _n / | (2 * x_n) |
 498 |     |             //
 499 |     |             // For the first iteration, we have a special case where x_0 is known:
 500 |     |             // _1 = _0 / | (2 * x_0) |
 501 |     |             //      (2**(e-2)) / (2 * (2**(e-1) + 2**(e-2)))
 502 |     |             //      2**(2*e-4) / (3 * 2**(e-1))
 503 |     |             //      2**(e-3) / 3
 504 |     |             //      2**(e-3-log2(3))
 505 |     |             //      2**(e-4.5)
 506 |     |             //
 507 |     |             // For the following iterations, we use the fact that, 2**(e-1)  sqrt(a)  x_n:
 508 |     |             // _{n+1} = _n / | (2 * x_n) |
 509 |     |             //          (2**(e-k)) / (2 * 2**(e-1))
 510 |     |             //          2**(2*e-2*k) / 2**e
 511 |     |             //          2**(e-2*k)
 512 |     |             xn = (xn + a / xn) >> 1; // _1 := | x_1 - sqrt(a) |  2**(e-4.5)  -- special case, see above
 513 |     |             xn = (xn + a / xn) >> 1; // _2 := | x_2 - sqrt(a) |  2**(e-9)    -- general case with k = 4.5
 514 |     |             xn = (xn + a / xn) >> 1; // _3 := | x_3 - sqrt(a) |  2**(e-18)   -- general case with k = 9
 515 |     |             xn = (xn + a / xn) >> 1; // _4 := | x_4 - sqrt(a) |  2**(e-36)   -- general case with k = 18
 516 |     |             xn = (xn + a / xn) >> 1; // _5 := | x_5 - sqrt(a) |  2**(e-72)   -- general case with k = 36
 517 |     |             xn = (xn + a / xn) >> 1; // _6 := | x_6 - sqrt(a) |  2**(e-144)  -- general case with k = 72
 518 |     | 
 519 |     |             // Because e  128 (as discussed during the first estimation phase), we know have reached a precision
 520 |     |             // _6  2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either
 521 |     |             // sqrt(a) or sqrt(a) + 1.
 522 |     |             return xn - SafeCast.toUint(xn > a / xn);
 523 |     |         }
 524 |     |     }
 525 |     | 
 526 |     |     /**
 527 |     |      * @dev Calculates sqrt(a), following the selected rounding direction.
 528 |     |      */
 529 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 530 |     |         unchecked {
 531 |     |             uint256 result = sqrt(a);
 532 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);
 533 |     |         }
 534 |     |     }
 535 |     | 
 536 |     |     /**
 537 |     |      * @dev Return the log in base 2 of a positive value rounded towards zero.
 538 |     |      * Returns 0 if given 0.
 539 |     |      */
 540 |     |     function log2(uint256 value) internal pure returns (uint256) {
 541 |     |         uint256 result = 0;
 542 |     |         uint256 exp;
 543 |     |         unchecked {
 544 |     |             exp = 128 * SafeCast.toUint(value > (1 << 128) - 1);
 545 |     |             value >>= exp;
 546 |     |             result += exp;
 547 |     | 
 548 |     |             exp = 64 * SafeCast.toUint(value > (1 << 64) - 1);
 549 |     |             value >>= exp;
 550 |     |             result += exp;
 551 |     | 
 552 |     |             exp = 32 * SafeCast.toUint(value > (1 << 32) - 1);
 553 |     |             value >>= exp;
 554 |     |             result += exp;
 555 |     | 
 556 |     |             exp = 16 * SafeCast.toUint(value > (1 << 16) - 1);
 557 |     |             value >>= exp;
 558 |     |             result += exp;
 559 |     | 
 560 |     |             exp = 8 * SafeCast.toUint(value > (1 << 8) - 1);
 561 |     |             value >>= exp;
 562 |     |             result += exp;
 563 |     | 
 564 |     |             exp = 4 * SafeCast.toUint(value > (1 << 4) - 1);
 565 |     |             value >>= exp;
 566 |     |             result += exp;
 567 |     | 
 568 |     |             exp = 2 * SafeCast.toUint(value > (1 << 2) - 1);
 569 |     |             value >>= exp;
 570 |     |             result += exp;
 571 |     | 
 572 |     |             result += SafeCast.toUint(value > 1);
 573 |     |         }
 574 |     |         return result;
 575 |     |     }
 576 |     | 
 577 |     |     /**
 578 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 579 |     |      * Returns 0 if given 0.
 580 |     |      */
 581 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 582 |     |         unchecked {
 583 |     |             uint256 result = log2(value);
 584 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);
 585 |     |         }
 586 |     |     }
 587 |     | 
 588 |     |     /**
 589 |     |      * @dev Return the log in base 10 of a positive value rounded towards zero.
 590 |     |      * Returns 0 if given 0.
 591 |     |      */
 592 |     |     function log10(uint256 value) internal pure returns (uint256) {
 593 |     |         uint256 result = 0;
 594 |     |         unchecked {
 595 |     |             if (value >= 10 ** 64) {
 596 |     |                 value /= 10 ** 64;
 597 |     |                 result += 64;
 598 |     |             }
 599 |     |             if (value >= 10 ** 32) {
 600 |     |                 value /= 10 ** 32;
 601 |     |                 result += 32;
 602 |     |             }
 603 |     |             if (value >= 10 ** 16) {
 604 |     |                 value /= 10 ** 16;
 605 |     |                 result += 16;
 606 |     |             }
 607 |     |             if (value >= 10 ** 8) {
 608 |     |                 value /= 10 ** 8;
 609 |     |                 result += 8;
 610 |     |             }
 611 |     |             if (value >= 10 ** 4) {
 612 |     |                 value /= 10 ** 4;
 613 |     |                 result += 4;
 614 |     |             }
 615 |     |             if (value >= 10 ** 2) {
 616 |     |                 value /= 10 ** 2;
 617 |     |                 result += 2;
 618 |     |             }
 619 |     |             if (value >= 10 ** 1) {
 620 |     |                 result += 1;
 621 |     |             }
 622 |     |         }
 623 |     |         return result;
 624 |     |     }
 625 |     | 
 626 |     |     /**
 627 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 628 |     |      * Returns 0 if given 0.
 629 |     |      */
 630 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 631 |     |         unchecked {
 632 |     |             uint256 result = log10(value);
 633 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);
 634 |     |         }
 635 |     |     }
 636 |     | 
 637 |     |     /**
 638 |     |      * @dev Return the log in base 256 of a positive value rounded towards zero.
 639 |     |      * Returns 0 if given 0.
 640 |     |      *
 641 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 642 |     |      */
 643 |     |     function log256(uint256 value) internal pure returns (uint256) {
 644 |     |         uint256 result = 0;
 645 |     |         uint256 isGt;
 646 |     |         unchecked {
 647 |     |             isGt = SafeCast.toUint(value > (1 << 128) - 1);
 648 |     |             value >>= isGt * 128;
 649 |     |             result += isGt * 16;
 650 |     | 
 651 |     |             isGt = SafeCast.toUint(value > (1 << 64) - 1);
 652 |     |             value >>= isGt * 64;
 653 |     |             result += isGt * 8;
 654 |     | 
 655 |     |             isGt = SafeCast.toUint(value > (1 << 32) - 1);
 656 |     |             value >>= isGt * 32;
 657 |     |             result += isGt * 4;
 658 |     | 
 659 |     |             isGt = SafeCast.toUint(value > (1 << 16) - 1);
 660 |     |             value >>= isGt * 16;
 661 |     |             result += isGt * 2;
 662 |     | 
 663 |     |             result += SafeCast.toUint(value > (1 << 8) - 1);
 664 |     |         }
 665 |     |         return result;
 666 |     |     }
 667 |     | 
 668 |     |     /**
 669 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 670 |     |      * Returns 0 if given 0.
 671 |     |      */
 672 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 673 |     |         unchecked {
 674 |     |             uint256 result = log256(value);
 675 |     |             return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);
 676 |     |         }
 677 |     |     }
 678 |     | 
 679 |     |     /**
 680 |     |      * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.
 681 |     |      */
 682 |     |     function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {
 683 |     |         return uint8(rounding) % 2 == 1;
 684 |     |     }
 685 |     | }
 686 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)
    3 |     | // This file was procedurally generated from scripts/generate/templates/SafeCast.js.
    4 |     | 
    5 |     | pragma solidity ^0.8.20;
    6 |     | 
    7 |     | /**
    8 |     |  * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow
    9 |     |  * checks.
   10 |     |  *
   11 |     |  * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
   12 |     |  * easily result in undesired exploitation or bugs, since developers usually
   13 |     |  * assume that overflows raise errors. `SafeCast` restores this intuition by
   14 |     |  * reverting the transaction when such an operation overflows.
   15 |     |  *
   16 |     |  * Using this library instead of the unchecked operations eliminates an entire
   17 |     |  * class of bugs, so it's recommended to use it always.
   18 |     |  */
   19 |     | library SafeCast {
   20 |     |     /**
   21 |     |      * @dev Value doesn't fit in an uint of `bits` size.
   22 |     |      */
   23 |     |     error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);
   24 |     | 
   25 |     |     /**
   26 |     |      * @dev An int value doesn't fit in an uint of `bits` size.
   27 |     |      */
   28 |     |     error SafeCastOverflowedIntToUint(int256 value);
   29 |     | 
   30 |     |     /**
   31 |     |      * @dev Value doesn't fit in an int of `bits` size.
   32 |     |      */
   33 |     |     error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);
   34 |     | 
   35 |     |     /**
   36 |     |      * @dev An uint value doesn't fit in an int of `bits` size.
   37 |     |      */
   38 |     |     error SafeCastOverflowedUintToInt(uint256 value);
   39 |     | 
   40 |     |     /**
   41 |     |      * @dev Returns the downcasted uint248 from uint256, reverting on
   42 |     |      * overflow (when the input is greater than largest uint248).
   43 |     |      *
   44 |     |      * Counterpart to Solidity's `uint248` operator.
   45 |     |      *
   46 |     |      * Requirements:
   47 |     |      *
   48 |     |      * - input must fit into 248 bits
   49 |     |      */
   50 |     |     function toUint248(uint256 value) internal pure returns (uint248) {
   51 |     |         if (value > type(uint248).max) {
   52 |     |             revert SafeCastOverflowedUintDowncast(248, value);
   53 |     |         }
   54 |     |         return uint248(value);
   55 |     |     }
   56 |     | 
   57 |     |     /**
   58 |     |      * @dev Returns the downcasted uint240 from uint256, reverting on
   59 |     |      * overflow (when the input is greater than largest uint240).
   60 |     |      *
   61 |     |      * Counterpart to Solidity's `uint240` operator.
   62 |     |      *
   63 |     |      * Requirements:
   64 |     |      *
   65 |     |      * - input must fit into 240 bits
   66 |     |      */
   67 |     |     function toUint240(uint256 value) internal pure returns (uint240) {
   68 |     |         if (value > type(uint240).max) {
   69 |     |             revert SafeCastOverflowedUintDowncast(240, value);
   70 |     |         }
   71 |     |         return uint240(value);
   72 |     |     }
   73 |     | 
   74 |     |     /**
   75 |     |      * @dev Returns the downcasted uint232 from uint256, reverting on
   76 |     |      * overflow (when the input is greater than largest uint232).
   77 |     |      *
   78 |     |      * Counterpart to Solidity's `uint232` operator.
   79 |     |      *
   80 |     |      * Requirements:
   81 |     |      *
   82 |     |      * - input must fit into 232 bits
   83 |     |      */
   84 |     |     function toUint232(uint256 value) internal pure returns (uint232) {
   85 |     |         if (value > type(uint232).max) {
   86 |     |             revert SafeCastOverflowedUintDowncast(232, value);
   87 |     |         }
   88 |     |         return uint232(value);
   89 |     |     }
   90 |     | 
   91 |     |     /**
   92 |     |      * @dev Returns the downcasted uint224 from uint256, reverting on
   93 |     |      * overflow (when the input is greater than largest uint224).
   94 |     |      *
   95 |     |      * Counterpart to Solidity's `uint224` operator.
   96 |     |      *
   97 |     |      * Requirements:
   98 |     |      *
   99 |     |      * - input must fit into 224 bits
  100 |     |      */
  101 |     |     function toUint224(uint256 value) internal pure returns (uint224) {
  102 |     |         if (value > type(uint224).max) {
  103 |     |             revert SafeCastOverflowedUintDowncast(224, value);
  104 |     |         }
  105 |     |         return uint224(value);
  106 |     |     }
  107 |     | 
  108 |     |     /**
  109 |     |      * @dev Returns the downcasted uint216 from uint256, reverting on
  110 |     |      * overflow (when the input is greater than largest uint216).
  111 |     |      *
  112 |     |      * Counterpart to Solidity's `uint216` operator.
  113 |     |      *
  114 |     |      * Requirements:
  115 |     |      *
  116 |     |      * - input must fit into 216 bits
  117 |     |      */
  118 |     |     function toUint216(uint256 value) internal pure returns (uint216) {
  119 |     |         if (value > type(uint216).max) {
  120 |     |             revert SafeCastOverflowedUintDowncast(216, value);
  121 |     |         }
  122 |     |         return uint216(value);
  123 |     |     }
  124 |     | 
  125 |     |     /**
  126 |     |      * @dev Returns the downcasted uint208 from uint256, reverting on
  127 |     |      * overflow (when the input is greater than largest uint208).
  128 |     |      *
  129 |     |      * Counterpart to Solidity's `uint208` operator.
  130 |     |      *
  131 |     |      * Requirements:
  132 |     |      *
  133 |     |      * - input must fit into 208 bits
  134 |     |      */
  135 |     |     function toUint208(uint256 value) internal pure returns (uint208) {
  136 |     |         if (value > type(uint208).max) {
  137 |     |             revert SafeCastOverflowedUintDowncast(208, value);
  138 |     |         }
  139 |     |         return uint208(value);
  140 |     |     }
  141 |     | 
  142 |     |     /**
  143 |     |      * @dev Returns the downcasted uint200 from uint256, reverting on
  144 |     |      * overflow (when the input is greater than largest uint200).
  145 |     |      *
  146 |     |      * Counterpart to Solidity's `uint200` operator.
  147 |     |      *
  148 |     |      * Requirements:
  149 |     |      *
  150 |     |      * - input must fit into 200 bits
  151 |     |      */
  152 |     |     function toUint200(uint256 value) internal pure returns (uint200) {
  153 |     |         if (value > type(uint200).max) {
  154 |     |             revert SafeCastOverflowedUintDowncast(200, value);
  155 |     |         }
  156 |     |         return uint200(value);
  157 |     |     }
  158 |     | 
  159 |     |     /**
  160 |     |      * @dev Returns the downcasted uint192 from uint256, reverting on
  161 |     |      * overflow (when the input is greater than largest uint192).
  162 |     |      *
  163 |     |      * Counterpart to Solidity's `uint192` operator.
  164 |     |      *
  165 |     |      * Requirements:
  166 |     |      *
  167 |     |      * - input must fit into 192 bits
  168 |     |      */
  169 |     |     function toUint192(uint256 value) internal pure returns (uint192) {
  170 |     |         if (value > type(uint192).max) {
  171 |     |             revert SafeCastOverflowedUintDowncast(192, value);
  172 |     |         }
  173 |     |         return uint192(value);
  174 |     |     }
  175 |     | 
  176 |     |     /**
  177 |     |      * @dev Returns the downcasted uint184 from uint256, reverting on
  178 |     |      * overflow (when the input is greater than largest uint184).
  179 |     |      *
  180 |     |      * Counterpart to Solidity's `uint184` operator.
  181 |     |      *
  182 |     |      * Requirements:
  183 |     |      *
  184 |     |      * - input must fit into 184 bits
  185 |     |      */
  186 |     |     function toUint184(uint256 value) internal pure returns (uint184) {
  187 |     |         if (value > type(uint184).max) {
  188 |     |             revert SafeCastOverflowedUintDowncast(184, value);
  189 |     |         }
  190 |     |         return uint184(value);
  191 |     |     }
  192 |     | 
  193 |     |     /**
  194 |     |      * @dev Returns the downcasted uint176 from uint256, reverting on
  195 |     |      * overflow (when the input is greater than largest uint176).
  196 |     |      *
  197 |     |      * Counterpart to Solidity's `uint176` operator.
  198 |     |      *
  199 |     |      * Requirements:
  200 |     |      *
  201 |     |      * - input must fit into 176 bits
  202 |     |      */
  203 |     |     function toUint176(uint256 value) internal pure returns (uint176) {
  204 |     |         if (value > type(uint176).max) {
  205 |     |             revert SafeCastOverflowedUintDowncast(176, value);
  206 |     |         }
  207 |     |         return uint176(value);
  208 |     |     }
  209 |     | 
  210 |     |     /**
  211 |     |      * @dev Returns the downcasted uint168 from uint256, reverting on
  212 |     |      * overflow (when the input is greater than largest uint168).
  213 |     |      *
  214 |     |      * Counterpart to Solidity's `uint168` operator.
  215 |     |      *
  216 |     |      * Requirements:
  217 |     |      *
  218 |     |      * - input must fit into 168 bits
  219 |     |      */
  220 |     |     function toUint168(uint256 value) internal pure returns (uint168) {
  221 |     |         if (value > type(uint168).max) {
  222 |     |             revert SafeCastOverflowedUintDowncast(168, value);
  223 |     |         }
  224 |     |         return uint168(value);
  225 |     |     }
  226 |     | 
  227 |     |     /**
  228 |     |      * @dev Returns the downcasted uint160 from uint256, reverting on
  229 |     |      * overflow (when the input is greater than largest uint160).
  230 |     |      *
  231 |     |      * Counterpart to Solidity's `uint160` operator.
  232 |     |      *
  233 |     |      * Requirements:
  234 |     |      *
  235 |     |      * - input must fit into 160 bits
  236 |     |      */
  237 |     |     function toUint160(uint256 value) internal pure returns (uint160) {
  238 |     |         if (value > type(uint160).max) {
  239 |     |             revert SafeCastOverflowedUintDowncast(160, value);
  240 |     |         }
  241 |     |         return uint160(value);
  242 |     |     }
  243 |     | 
  244 |     |     /**
  245 |     |      * @dev Returns the downcasted uint152 from uint256, reverting on
  246 |     |      * overflow (when the input is greater than largest uint152).
  247 |     |      *
  248 |     |      * Counterpart to Solidity's `uint152` operator.
  249 |     |      *
  250 |     |      * Requirements:
  251 |     |      *
  252 |     |      * - input must fit into 152 bits
  253 |     |      */
  254 |     |     function toUint152(uint256 value) internal pure returns (uint152) {
  255 |     |         if (value > type(uint152).max) {
  256 |     |             revert SafeCastOverflowedUintDowncast(152, value);
  257 |     |         }
  258 |     |         return uint152(value);
  259 |     |     }
  260 |     | 
  261 |     |     /**
  262 |     |      * @dev Returns the downcasted uint144 from uint256, reverting on
  263 |     |      * overflow (when the input is greater than largest uint144).
  264 |     |      *
  265 |     |      * Counterpart to Solidity's `uint144` operator.
  266 |     |      *
  267 |     |      * Requirements:
  268 |     |      *
  269 |     |      * - input must fit into 144 bits
  270 |     |      */
  271 |     |     function toUint144(uint256 value) internal pure returns (uint144) {
  272 |     |         if (value > type(uint144).max) {
  273 |     |             revert SafeCastOverflowedUintDowncast(144, value);
  274 |     |         }
  275 |     |         return uint144(value);
  276 |     |     }
  277 |     | 
  278 |     |     /**
  279 |     |      * @dev Returns the downcasted uint136 from uint256, reverting on
  280 |     |      * overflow (when the input is greater than largest uint136).
  281 |     |      *
  282 |     |      * Counterpart to Solidity's `uint136` operator.
  283 |     |      *
  284 |     |      * Requirements:
  285 |     |      *
  286 |     |      * - input must fit into 136 bits
  287 |     |      */
  288 |     |     function toUint136(uint256 value) internal pure returns (uint136) {
  289 |     |         if (value > type(uint136).max) {
  290 |     |             revert SafeCastOverflowedUintDowncast(136, value);
  291 |     |         }
  292 |     |         return uint136(value);
  293 |     |     }
  294 |     | 
  295 |     |     /**
  296 |     |      * @dev Returns the downcasted uint128 from uint256, reverting on
  297 |     |      * overflow (when the input is greater than largest uint128).
  298 |     |      *
  299 |     |      * Counterpart to Solidity's `uint128` operator.
  300 |     |      *
  301 |     |      * Requirements:
  302 |     |      *
  303 |     |      * - input must fit into 128 bits
  304 |     |      */
  305 |     |     function toUint128(uint256 value) internal pure returns (uint128) {
  306 |     |         if (value > type(uint128).max) {
  307 |     |             revert SafeCastOverflowedUintDowncast(128, value);
  308 |     |         }
  309 |     |         return uint128(value);
  310 |     |     }
  311 |     | 
  312 |     |     /**
  313 |     |      * @dev Returns the downcasted uint120 from uint256, reverting on
  314 |     |      * overflow (when the input is greater than largest uint120).
  315 |     |      *
  316 |     |      * Counterpart to Solidity's `uint120` operator.
  317 |     |      *
  318 |     |      * Requirements:
  319 |     |      *
  320 |     |      * - input must fit into 120 bits
  321 |     |      */
  322 |     |     function toUint120(uint256 value) internal pure returns (uint120) {
  323 |     |         if (value > type(uint120).max) {
  324 |     |             revert SafeCastOverflowedUintDowncast(120, value);
  325 |     |         }
  326 |     |         return uint120(value);
  327 |     |     }
  328 |     | 
  329 |     |     /**
  330 |     |      * @dev Returns the downcasted uint112 from uint256, reverting on
  331 |     |      * overflow (when the input is greater than largest uint112).
  332 |     |      *
  333 |     |      * Counterpart to Solidity's `uint112` operator.
  334 |     |      *
  335 |     |      * Requirements:
  336 |     |      *
  337 |     |      * - input must fit into 112 bits
  338 |     |      */
  339 |     |     function toUint112(uint256 value) internal pure returns (uint112) {
  340 |     |         if (value > type(uint112).max) {
  341 |     |             revert SafeCastOverflowedUintDowncast(112, value);
  342 |     |         }
  343 |     |         return uint112(value);
  344 |     |     }
  345 |     | 
  346 |     |     /**
  347 |     |      * @dev Returns the downcasted uint104 from uint256, reverting on
  348 |     |      * overflow (when the input is greater than largest uint104).
  349 |     |      *
  350 |     |      * Counterpart to Solidity's `uint104` operator.
  351 |     |      *
  352 |     |      * Requirements:
  353 |     |      *
  354 |     |      * - input must fit into 104 bits
  355 |     |      */
  356 |     |     function toUint104(uint256 value) internal pure returns (uint104) {
  357 |     |         if (value > type(uint104).max) {
  358 |     |             revert SafeCastOverflowedUintDowncast(104, value);
  359 |     |         }
  360 |     |         return uint104(value);
  361 |     |     }
  362 |     | 
  363 |     |     /**
  364 |     |      * @dev Returns the downcasted uint96 from uint256, reverting on
  365 |     |      * overflow (when the input is greater than largest uint96).
  366 |     |      *
  367 |     |      * Counterpart to Solidity's `uint96` operator.
  368 |     |      *
  369 |     |      * Requirements:
  370 |     |      *
  371 |     |      * - input must fit into 96 bits
  372 |     |      */
  373 |     |     function toUint96(uint256 value) internal pure returns (uint96) {
  374 |     |         if (value > type(uint96).max) {
  375 |     |             revert SafeCastOverflowedUintDowncast(96, value);
  376 |     |         }
  377 |     |         return uint96(value);
  378 |     |     }
  379 |     | 
  380 |     |     /**
  381 |     |      * @dev Returns the downcasted uint88 from uint256, reverting on
  382 |     |      * overflow (when the input is greater than largest uint88).
  383 |     |      *
  384 |     |      * Counterpart to Solidity's `uint88` operator.
  385 |     |      *
  386 |     |      * Requirements:
  387 |     |      *
  388 |     |      * - input must fit into 88 bits
  389 |     |      */
  390 |     |     function toUint88(uint256 value) internal pure returns (uint88) {
  391 |     |         if (value > type(uint88).max) {
  392 |     |             revert SafeCastOverflowedUintDowncast(88, value);
  393 |     |         }
  394 |     |         return uint88(value);
  395 |     |     }
  396 |     | 
  397 |     |     /**
  398 |     |      * @dev Returns the downcasted uint80 from uint256, reverting on
  399 |     |      * overflow (when the input is greater than largest uint80).
  400 |     |      *
  401 |     |      * Counterpart to Solidity's `uint80` operator.
  402 |     |      *
  403 |     |      * Requirements:
  404 |     |      *
  405 |     |      * - input must fit into 80 bits
  406 |     |      */
  407 |     |     function toUint80(uint256 value) internal pure returns (uint80) {
  408 |     |         if (value > type(uint80).max) {
  409 |     |             revert SafeCastOverflowedUintDowncast(80, value);
  410 |     |         }
  411 |     |         return uint80(value);
  412 |     |     }
  413 |     | 
  414 |     |     /**
  415 |     |      * @dev Returns the downcasted uint72 from uint256, reverting on
  416 |     |      * overflow (when the input is greater than largest uint72).
  417 |     |      *
  418 |     |      * Counterpart to Solidity's `uint72` operator.
  419 |     |      *
  420 |     |      * Requirements:
  421 |     |      *
  422 |     |      * - input must fit into 72 bits
  423 |     |      */
  424 |     |     function toUint72(uint256 value) internal pure returns (uint72) {
  425 |     |         if (value > type(uint72).max) {
  426 |     |             revert SafeCastOverflowedUintDowncast(72, value);
  427 |     |         }
  428 |     |         return uint72(value);
  429 |     |     }
  430 |     | 
  431 |     |     /**
  432 |     |      * @dev Returns the downcasted uint64 from uint256, reverting on
  433 |     |      * overflow (when the input is greater than largest uint64).
  434 |     |      *
  435 |     |      * Counterpart to Solidity's `uint64` operator.
  436 |     |      *
  437 |     |      * Requirements:
  438 |     |      *
  439 |     |      * - input must fit into 64 bits
  440 |     |      */
  441 |     |     function toUint64(uint256 value) internal pure returns (uint64) {
  442 |     |         if (value > type(uint64).max) {
  443 |     |             revert SafeCastOverflowedUintDowncast(64, value);
  444 |     |         }
  445 |     |         return uint64(value);
  446 |     |     }
  447 |     | 
  448 |     |     /**
  449 |     |      * @dev Returns the downcasted uint56 from uint256, reverting on
  450 |     |      * overflow (when the input is greater than largest uint56).
  451 |     |      *
  452 |     |      * Counterpart to Solidity's `uint56` operator.
  453 |     |      *
  454 |     |      * Requirements:
  455 |     |      *
  456 |     |      * - input must fit into 56 bits
  457 |     |      */
  458 |     |     function toUint56(uint256 value) internal pure returns (uint56) {
  459 |     |         if (value > type(uint56).max) {
  460 |     |             revert SafeCastOverflowedUintDowncast(56, value);
  461 |     |         }
  462 |     |         return uint56(value);
  463 |     |     }
  464 |     | 
  465 |     |     /**
  466 |     |      * @dev Returns the downcasted uint48 from uint256, reverting on
  467 |     |      * overflow (when the input is greater than largest uint48).
  468 |     |      *
  469 |     |      * Counterpart to Solidity's `uint48` operator.
  470 |     |      *
  471 |     |      * Requirements:
  472 |     |      *
  473 |     |      * - input must fit into 48 bits
  474 |     |      */
  475 |     |     function toUint48(uint256 value) internal pure returns (uint48) {
  476 |     |         if (value > type(uint48).max) {
  477 |     |             revert SafeCastOverflowedUintDowncast(48, value);
  478 |     |         }
  479 |     |         return uint48(value);
  480 |     |     }
  481 |     | 
  482 |     |     /**
  483 |     |      * @dev Returns the downcasted uint40 from uint256, reverting on
  484 |     |      * overflow (when the input is greater than largest uint40).
  485 |     |      *
  486 |     |      * Counterpart to Solidity's `uint40` operator.
  487 |     |      *
  488 |     |      * Requirements:
  489 |     |      *
  490 |     |      * - input must fit into 40 bits
  491 |     |      */
  492 |     |     function toUint40(uint256 value) internal pure returns (uint40) {
  493 |     |         if (value > type(uint40).max) {
  494 |     |             revert SafeCastOverflowedUintDowncast(40, value);
  495 |     |         }
  496 |     |         return uint40(value);
  497 |     |     }
  498 |     | 
  499 |     |     /**
  500 |     |      * @dev Returns the downcasted uint32 from uint256, reverting on
  501 |     |      * overflow (when the input is greater than largest uint32).
  502 |     |      *
  503 |     |      * Counterpart to Solidity's `uint32` operator.
  504 |     |      *
  505 |     |      * Requirements:
  506 |     |      *
  507 |     |      * - input must fit into 32 bits
  508 |     |      */
  509 |     |     function toUint32(uint256 value) internal pure returns (uint32) {
  510 |     |         if (value > type(uint32).max) {
  511 |     |             revert SafeCastOverflowedUintDowncast(32, value);
  512 |     |         }
  513 |     |         return uint32(value);
  514 |     |     }
  515 |     | 
  516 |     |     /**
  517 |     |      * @dev Returns the downcasted uint24 from uint256, reverting on
  518 |     |      * overflow (when the input is greater than largest uint24).
  519 |     |      *
  520 |     |      * Counterpart to Solidity's `uint24` operator.
  521 |     |      *
  522 |     |      * Requirements:
  523 |     |      *
  524 |     |      * - input must fit into 24 bits
  525 |     |      */
  526 |     |     function toUint24(uint256 value) internal pure returns (uint24) {
  527 |     |         if (value > type(uint24).max) {
  528 |     |             revert SafeCastOverflowedUintDowncast(24, value);
  529 |     |         }
  530 |     |         return uint24(value);
  531 |     |     }
  532 |     | 
  533 |     |     /**
  534 |     |      * @dev Returns the downcasted uint16 from uint256, reverting on
  535 |     |      * overflow (when the input is greater than largest uint16).
  536 |     |      *
  537 |     |      * Counterpart to Solidity's `uint16` operator.
  538 |     |      *
  539 |     |      * Requirements:
  540 |     |      *
  541 |     |      * - input must fit into 16 bits
  542 |     |      */
  543 |     |     function toUint16(uint256 value) internal pure returns (uint16) {
  544 |     |         if (value > type(uint16).max) {
  545 |     |             revert SafeCastOverflowedUintDowncast(16, value);
  546 |     |         }
  547 |     |         return uint16(value);
  548 |     |     }
  549 |     | 
  550 |     |     /**
  551 |     |      * @dev Returns the downcasted uint8 from uint256, reverting on
  552 |     |      * overflow (when the input is greater than largest uint8).
  553 |     |      *
  554 |     |      * Counterpart to Solidity's `uint8` operator.
  555 |     |      *
  556 |     |      * Requirements:
  557 |     |      *
  558 |     |      * - input must fit into 8 bits
  559 |     |      */
  560 |     |     function toUint8(uint256 value) internal pure returns (uint8) {
  561 |     |         if (value > type(uint8).max) {
  562 |     |             revert SafeCastOverflowedUintDowncast(8, value);
  563 |     |         }
  564 |     |         return uint8(value);
  565 |     |     }
  566 |     | 
  567 |     |     /**
  568 |     |      * @dev Converts a signed int256 into an unsigned uint256.
  569 |     |      *
  570 |     |      * Requirements:
  571 |     |      *
  572 |     |      * - input must be greater than or equal to 0.
  573 |     |      */
  574 |     |     function toUint256(int256 value) internal pure returns (uint256) {
  575 |     |         if (value < 0) {
  576 |     |             revert SafeCastOverflowedIntToUint(value);
  577 |     |         }
  578 |     |         return uint256(value);
  579 |     |     }
  580 |     | 
  581 |     |     /**
  582 |     |      * @dev Returns the downcasted int248 from int256, reverting on
  583 |     |      * overflow (when the input is less than smallest int248 or
  584 |     |      * greater than largest int248).
  585 |     |      *
  586 |     |      * Counterpart to Solidity's `int248` operator.
  587 |     |      *
  588 |     |      * Requirements:
  589 |     |      *
  590 |     |      * - input must fit into 248 bits
  591 |     |      */
  592 |     |     function toInt248(int256 value) internal pure returns (int248 downcasted) {
  593 |     |         downcasted = int248(value);
  594 |     |         if (downcasted != value) {
  595 |     |             revert SafeCastOverflowedIntDowncast(248, value);
  596 |     |         }
  597 |     |     }
  598 |     | 
  599 |     |     /**
  600 |     |      * @dev Returns the downcasted int240 from int256, reverting on
  601 |     |      * overflow (when the input is less than smallest int240 or
  602 |     |      * greater than largest int240).
  603 |     |      *
  604 |     |      * Counterpart to Solidity's `int240` operator.
  605 |     |      *
  606 |     |      * Requirements:
  607 |     |      *
  608 |     |      * - input must fit into 240 bits
  609 |     |      */
  610 |     |     function toInt240(int256 value) internal pure returns (int240 downcasted) {
  611 |     |         downcasted = int240(value);
  612 |     |         if (downcasted != value) {
  613 |     |             revert SafeCastOverflowedIntDowncast(240, value);
  614 |     |         }
  615 |     |     }
  616 |     | 
  617 |     |     /**
  618 |     |      * @dev Returns the downcasted int232 from int256, reverting on
  619 |     |      * overflow (when the input is less than smallest int232 or
  620 |     |      * greater than largest int232).
  621 |     |      *
  622 |     |      * Counterpart to Solidity's `int232` operator.
  623 |     |      *
  624 |     |      * Requirements:
  625 |     |      *
  626 |     |      * - input must fit into 232 bits
  627 |     |      */
  628 |     |     function toInt232(int256 value) internal pure returns (int232 downcasted) {
  629 |     |         downcasted = int232(value);
  630 |     |         if (downcasted != value) {
  631 |     |             revert SafeCastOverflowedIntDowncast(232, value);
  632 |     |         }
  633 |     |     }
  634 |     | 
  635 |     |     /**
  636 |     |      * @dev Returns the downcasted int224 from int256, reverting on
  637 |     |      * overflow (when the input is less than smallest int224 or
  638 |     |      * greater than largest int224).
  639 |     |      *
  640 |     |      * Counterpart to Solidity's `int224` operator.
  641 |     |      *
  642 |     |      * Requirements:
  643 |     |      *
  644 |     |      * - input must fit into 224 bits
  645 |     |      */
  646 |     |     function toInt224(int256 value) internal pure returns (int224 downcasted) {
  647 |     |         downcasted = int224(value);
  648 |     |         if (downcasted != value) {
  649 |     |             revert SafeCastOverflowedIntDowncast(224, value);
  650 |     |         }
  651 |     |     }
  652 |     | 
  653 |     |     /**
  654 |     |      * @dev Returns the downcasted int216 from int256, reverting on
  655 |     |      * overflow (when the input is less than smallest int216 or
  656 |     |      * greater than largest int216).
  657 |     |      *
  658 |     |      * Counterpart to Solidity's `int216` operator.
  659 |     |      *
  660 |     |      * Requirements:
  661 |     |      *
  662 |     |      * - input must fit into 216 bits
  663 |     |      */
  664 |     |     function toInt216(int256 value) internal pure returns (int216 downcasted) {
  665 |     |         downcasted = int216(value);
  666 |     |         if (downcasted != value) {
  667 |     |             revert SafeCastOverflowedIntDowncast(216, value);
  668 |     |         }
  669 |     |     }
  670 |     | 
  671 |     |     /**
  672 |     |      * @dev Returns the downcasted int208 from int256, reverting on
  673 |     |      * overflow (when the input is less than smallest int208 or
  674 |     |      * greater than largest int208).
  675 |     |      *
  676 |     |      * Counterpart to Solidity's `int208` operator.
  677 |     |      *
  678 |     |      * Requirements:
  679 |     |      *
  680 |     |      * - input must fit into 208 bits
  681 |     |      */
  682 |     |     function toInt208(int256 value) internal pure returns (int208 downcasted) {
  683 |     |         downcasted = int208(value);
  684 |     |         if (downcasted != value) {
  685 |     |             revert SafeCastOverflowedIntDowncast(208, value);
  686 |     |         }
  687 |     |     }
  688 |     | 
  689 |     |     /**
  690 |     |      * @dev Returns the downcasted int200 from int256, reverting on
  691 |     |      * overflow (when the input is less than smallest int200 or
  692 |     |      * greater than largest int200).
  693 |     |      *
  694 |     |      * Counterpart to Solidity's `int200` operator.
  695 |     |      *
  696 |     |      * Requirements:
  697 |     |      *
  698 |     |      * - input must fit into 200 bits
  699 |     |      */
  700 |     |     function toInt200(int256 value) internal pure returns (int200 downcasted) {
  701 |     |         downcasted = int200(value);
  702 |     |         if (downcasted != value) {
  703 |     |             revert SafeCastOverflowedIntDowncast(200, value);
  704 |     |         }
  705 |     |     }
  706 |     | 
  707 |     |     /**
  708 |     |      * @dev Returns the downcasted int192 from int256, reverting on
  709 |     |      * overflow (when the input is less than smallest int192 or
  710 |     |      * greater than largest int192).
  711 |     |      *
  712 |     |      * Counterpart to Solidity's `int192` operator.
  713 |     |      *
  714 |     |      * Requirements:
  715 |     |      *
  716 |     |      * - input must fit into 192 bits
  717 |     |      */
  718 |     |     function toInt192(int256 value) internal pure returns (int192 downcasted) {
  719 |     |         downcasted = int192(value);
  720 |     |         if (downcasted != value) {
  721 |     |             revert SafeCastOverflowedIntDowncast(192, value);
  722 |     |         }
  723 |     |     }
  724 |     | 
  725 |     |     /**
  726 |     |      * @dev Returns the downcasted int184 from int256, reverting on
  727 |     |      * overflow (when the input is less than smallest int184 or
  728 |     |      * greater than largest int184).
  729 |     |      *
  730 |     |      * Counterpart to Solidity's `int184` operator.
  731 |     |      *
  732 |     |      * Requirements:
  733 |     |      *
  734 |     |      * - input must fit into 184 bits
  735 |     |      */
  736 |     |     function toInt184(int256 value) internal pure returns (int184 downcasted) {
  737 |     |         downcasted = int184(value);
  738 |     |         if (downcasted != value) {
  739 |     |             revert SafeCastOverflowedIntDowncast(184, value);
  740 |     |         }
  741 |     |     }
  742 |     | 
  743 |     |     /**
  744 |     |      * @dev Returns the downcasted int176 from int256, reverting on
  745 |     |      * overflow (when the input is less than smallest int176 or
  746 |     |      * greater than largest int176).
  747 |     |      *
  748 |     |      * Counterpart to Solidity's `int176` operator.
  749 |     |      *
  750 |     |      * Requirements:
  751 |     |      *
  752 |     |      * - input must fit into 176 bits
  753 |     |      */
  754 |     |     function toInt176(int256 value) internal pure returns (int176 downcasted) {
  755 |     |         downcasted = int176(value);
  756 |     |         if (downcasted != value) {
  757 |     |             revert SafeCastOverflowedIntDowncast(176, value);
  758 |     |         }
  759 |     |     }
  760 |     | 
  761 |     |     /**
  762 |     |      * @dev Returns the downcasted int168 from int256, reverting on
  763 |     |      * overflow (when the input is less than smallest int168 or
  764 |     |      * greater than largest int168).
  765 |     |      *
  766 |     |      * Counterpart to Solidity's `int168` operator.
  767 |     |      *
  768 |     |      * Requirements:
  769 |     |      *
  770 |     |      * - input must fit into 168 bits
  771 |     |      */
  772 |     |     function toInt168(int256 value) internal pure returns (int168 downcasted) {
  773 |     |         downcasted = int168(value);
  774 |     |         if (downcasted != value) {
  775 |     |             revert SafeCastOverflowedIntDowncast(168, value);
  776 |     |         }
  777 |     |     }
  778 |     | 
  779 |     |     /**
  780 |     |      * @dev Returns the downcasted int160 from int256, reverting on
  781 |     |      * overflow (when the input is less than smallest int160 or
  782 |     |      * greater than largest int160).
  783 |     |      *
  784 |     |      * Counterpart to Solidity's `int160` operator.
  785 |     |      *
  786 |     |      * Requirements:
  787 |     |      *
  788 |     |      * - input must fit into 160 bits
  789 |     |      */
  790 |     |     function toInt160(int256 value) internal pure returns (int160 downcasted) {
  791 |     |         downcasted = int160(value);
  792 |     |         if (downcasted != value) {
  793 |     |             revert SafeCastOverflowedIntDowncast(160, value);
  794 |     |         }
  795 |     |     }
  796 |     | 
  797 |     |     /**
  798 |     |      * @dev Returns the downcasted int152 from int256, reverting on
  799 |     |      * overflow (when the input is less than smallest int152 or
  800 |     |      * greater than largest int152).
  801 |     |      *
  802 |     |      * Counterpart to Solidity's `int152` operator.
  803 |     |      *
  804 |     |      * Requirements:
  805 |     |      *
  806 |     |      * - input must fit into 152 bits
  807 |     |      */
  808 |     |     function toInt152(int256 value) internal pure returns (int152 downcasted) {
  809 |     |         downcasted = int152(value);
  810 |     |         if (downcasted != value) {
  811 |     |             revert SafeCastOverflowedIntDowncast(152, value);
  812 |     |         }
  813 |     |     }
  814 |     | 
  815 |     |     /**
  816 |     |      * @dev Returns the downcasted int144 from int256, reverting on
  817 |     |      * overflow (when the input is less than smallest int144 or
  818 |     |      * greater than largest int144).
  819 |     |      *
  820 |     |      * Counterpart to Solidity's `int144` operator.
  821 |     |      *
  822 |     |      * Requirements:
  823 |     |      *
  824 |     |      * - input must fit into 144 bits
  825 |     |      */
  826 |     |     function toInt144(int256 value) internal pure returns (int144 downcasted) {
  827 |     |         downcasted = int144(value);
  828 |     |         if (downcasted != value) {
  829 |     |             revert SafeCastOverflowedIntDowncast(144, value);
  830 |     |         }
  831 |     |     }
  832 |     | 
  833 |     |     /**
  834 |     |      * @dev Returns the downcasted int136 from int256, reverting on
  835 |     |      * overflow (when the input is less than smallest int136 or
  836 |     |      * greater than largest int136).
  837 |     |      *
  838 |     |      * Counterpart to Solidity's `int136` operator.
  839 |     |      *
  840 |     |      * Requirements:
  841 |     |      *
  842 |     |      * - input must fit into 136 bits
  843 |     |      */
  844 |     |     function toInt136(int256 value) internal pure returns (int136 downcasted) {
  845 |     |         downcasted = int136(value);
  846 |     |         if (downcasted != value) {
  847 |     |             revert SafeCastOverflowedIntDowncast(136, value);
  848 |     |         }
  849 |     |     }
  850 |     | 
  851 |     |     /**
  852 |     |      * @dev Returns the downcasted int128 from int256, reverting on
  853 |     |      * overflow (when the input is less than smallest int128 or
  854 |     |      * greater than largest int128).
  855 |     |      *
  856 |     |      * Counterpart to Solidity's `int128` operator.
  857 |     |      *
  858 |     |      * Requirements:
  859 |     |      *
  860 |     |      * - input must fit into 128 bits
  861 |     |      */
  862 |     |     function toInt128(int256 value) internal pure returns (int128 downcasted) {
  863 |     |         downcasted = int128(value);
  864 |     |         if (downcasted != value) {
  865 |     |             revert SafeCastOverflowedIntDowncast(128, value);
  866 |     |         }
  867 |     |     }
  868 |     | 
  869 |     |     /**
  870 |     |      * @dev Returns the downcasted int120 from int256, reverting on
  871 |     |      * overflow (when the input is less than smallest int120 or
  872 |     |      * greater than largest int120).
  873 |     |      *
  874 |     |      * Counterpart to Solidity's `int120` operator.
  875 |     |      *
  876 |     |      * Requirements:
  877 |     |      *
  878 |     |      * - input must fit into 120 bits
  879 |     |      */
  880 |     |     function toInt120(int256 value) internal pure returns (int120 downcasted) {
  881 |     |         downcasted = int120(value);
  882 |     |         if (downcasted != value) {
  883 |     |             revert SafeCastOverflowedIntDowncast(120, value);
  884 |     |         }
  885 |     |     }
  886 |     | 
  887 |     |     /**
  888 |     |      * @dev Returns the downcasted int112 from int256, reverting on
  889 |     |      * overflow (when the input is less than smallest int112 or
  890 |     |      * greater than largest int112).
  891 |     |      *
  892 |     |      * Counterpart to Solidity's `int112` operator.
  893 |     |      *
  894 |     |      * Requirements:
  895 |     |      *
  896 |     |      * - input must fit into 112 bits
  897 |     |      */
  898 |     |     function toInt112(int256 value) internal pure returns (int112 downcasted) {
  899 |     |         downcasted = int112(value);
  900 |     |         if (downcasted != value) {
  901 |     |             revert SafeCastOverflowedIntDowncast(112, value);
  902 |     |         }
  903 |     |     }
  904 |     | 
  905 |     |     /**
  906 |     |      * @dev Returns the downcasted int104 from int256, reverting on
  907 |     |      * overflow (when the input is less than smallest int104 or
  908 |     |      * greater than largest int104).
  909 |     |      *
  910 |     |      * Counterpart to Solidity's `int104` operator.
  911 |     |      *
  912 |     |      * Requirements:
  913 |     |      *
  914 |     |      * - input must fit into 104 bits
  915 |     |      */
  916 |     |     function toInt104(int256 value) internal pure returns (int104 downcasted) {
  917 |     |         downcasted = int104(value);
  918 |     |         if (downcasted != value) {
  919 |     |             revert SafeCastOverflowedIntDowncast(104, value);
  920 |     |         }
  921 |     |     }
  922 |     | 
  923 |     |     /**
  924 |     |      * @dev Returns the downcasted int96 from int256, reverting on
  925 |     |      * overflow (when the input is less than smallest int96 or
  926 |     |      * greater than largest int96).
  927 |     |      *
  928 |     |      * Counterpart to Solidity's `int96` operator.
  929 |     |      *
  930 |     |      * Requirements:
  931 |     |      *
  932 |     |      * - input must fit into 96 bits
  933 |     |      */
  934 |     |     function toInt96(int256 value) internal pure returns (int96 downcasted) {
  935 |     |         downcasted = int96(value);
  936 |     |         if (downcasted != value) {
  937 |     |             revert SafeCastOverflowedIntDowncast(96, value);
  938 |     |         }
  939 |     |     }
  940 |     | 
  941 |     |     /**
  942 |     |      * @dev Returns the downcasted int88 from int256, reverting on
  943 |     |      * overflow (when the input is less than smallest int88 or
  944 |     |      * greater than largest int88).
  945 |     |      *
  946 |     |      * Counterpart to Solidity's `int88` operator.
  947 |     |      *
  948 |     |      * Requirements:
  949 |     |      *
  950 |     |      * - input must fit into 88 bits
  951 |     |      */
  952 |     |     function toInt88(int256 value) internal pure returns (int88 downcasted) {
  953 |     |         downcasted = int88(value);
  954 |     |         if (downcasted != value) {
  955 |     |             revert SafeCastOverflowedIntDowncast(88, value);
  956 |     |         }
  957 |     |     }
  958 |     | 
  959 |     |     /**
  960 |     |      * @dev Returns the downcasted int80 from int256, reverting on
  961 |     |      * overflow (when the input is less than smallest int80 or
  962 |     |      * greater than largest int80).
  963 |     |      *
  964 |     |      * Counterpart to Solidity's `int80` operator.
  965 |     |      *
  966 |     |      * Requirements:
  967 |     |      *
  968 |     |      * - input must fit into 80 bits
  969 |     |      */
  970 |     |     function toInt80(int256 value) internal pure returns (int80 downcasted) {
  971 |     |         downcasted = int80(value);
  972 |     |         if (downcasted != value) {
  973 |     |             revert SafeCastOverflowedIntDowncast(80, value);
  974 |     |         }
  975 |     |     }
  976 |     | 
  977 |     |     /**
  978 |     |      * @dev Returns the downcasted int72 from int256, reverting on
  979 |     |      * overflow (when the input is less than smallest int72 or
  980 |     |      * greater than largest int72).
  981 |     |      *
  982 |     |      * Counterpart to Solidity's `int72` operator.
  983 |     |      *
  984 |     |      * Requirements:
  985 |     |      *
  986 |     |      * - input must fit into 72 bits
  987 |     |      */
  988 |     |     function toInt72(int256 value) internal pure returns (int72 downcasted) {
  989 |     |         downcasted = int72(value);
  990 |     |         if (downcasted != value) {
  991 |     |             revert SafeCastOverflowedIntDowncast(72, value);
  992 |     |         }
  993 |     |     }
  994 |     | 
  995 |     |     /**
  996 |     |      * @dev Returns the downcasted int64 from int256, reverting on
  997 |     |      * overflow (when the input is less than smallest int64 or
  998 |     |      * greater than largest int64).
  999 |     |      *
 1000 |     |      * Counterpart to Solidity's `int64` operator.
 1001 |     |      *
 1002 |     |      * Requirements:
 1003 |     |      *
 1004 |     |      * - input must fit into 64 bits
 1005 |     |      */
 1006 |     |     function toInt64(int256 value) internal pure returns (int64 downcasted) {
 1007 |     |         downcasted = int64(value);
 1008 |     |         if (downcasted != value) {
 1009 |     |             revert SafeCastOverflowedIntDowncast(64, value);
 1010 |     |         }
 1011 |     |     }
 1012 |     | 
 1013 |     |     /**
 1014 |     |      * @dev Returns the downcasted int56 from int256, reverting on
 1015 |     |      * overflow (when the input is less than smallest int56 or
 1016 |     |      * greater than largest int56).
 1017 |     |      *
 1018 |     |      * Counterpart to Solidity's `int56` operator.
 1019 |     |      *
 1020 |     |      * Requirements:
 1021 |     |      *
 1022 |     |      * - input must fit into 56 bits
 1023 |     |      */
 1024 |     |     function toInt56(int256 value) internal pure returns (int56 downcasted) {
 1025 |     |         downcasted = int56(value);
 1026 |     |         if (downcasted != value) {
 1027 |     |             revert SafeCastOverflowedIntDowncast(56, value);
 1028 |     |         }
 1029 |     |     }
 1030 |     | 
 1031 |     |     /**
 1032 |     |      * @dev Returns the downcasted int48 from int256, reverting on
 1033 |     |      * overflow (when the input is less than smallest int48 or
 1034 |     |      * greater than largest int48).
 1035 |     |      *
 1036 |     |      * Counterpart to Solidity's `int48` operator.
 1037 |     |      *
 1038 |     |      * Requirements:
 1039 |     |      *
 1040 |     |      * - input must fit into 48 bits
 1041 |     |      */
 1042 |     |     function toInt48(int256 value) internal pure returns (int48 downcasted) {
 1043 |     |         downcasted = int48(value);
 1044 |     |         if (downcasted != value) {
 1045 |     |             revert SafeCastOverflowedIntDowncast(48, value);
 1046 |     |         }
 1047 |     |     }
 1048 |     | 
 1049 |     |     /**
 1050 |     |      * @dev Returns the downcasted int40 from int256, reverting on
 1051 |     |      * overflow (when the input is less than smallest int40 or
 1052 |     |      * greater than largest int40).
 1053 |     |      *
 1054 |     |      * Counterpart to Solidity's `int40` operator.
 1055 |     |      *
 1056 |     |      * Requirements:
 1057 |     |      *
 1058 |     |      * - input must fit into 40 bits
 1059 |     |      */
 1060 |     |     function toInt40(int256 value) internal pure returns (int40 downcasted) {
 1061 |     |         downcasted = int40(value);
 1062 |     |         if (downcasted != value) {
 1063 |     |             revert SafeCastOverflowedIntDowncast(40, value);
 1064 |     |         }
 1065 |     |     }
 1066 |     | 
 1067 |     |     /**
 1068 |     |      * @dev Returns the downcasted int32 from int256, reverting on
 1069 |     |      * overflow (when the input is less than smallest int32 or
 1070 |     |      * greater than largest int32).
 1071 |     |      *
 1072 |     |      * Counterpart to Solidity's `int32` operator.
 1073 |     |      *
 1074 |     |      * Requirements:
 1075 |     |      *
 1076 |     |      * - input must fit into 32 bits
 1077 |     |      */
 1078 |     |     function toInt32(int256 value) internal pure returns (int32 downcasted) {
 1079 |     |         downcasted = int32(value);
 1080 |     |         if (downcasted != value) {
 1081 |     |             revert SafeCastOverflowedIntDowncast(32, value);
 1082 |     |         }
 1083 |     |     }
 1084 |     | 
 1085 |     |     /**
 1086 |     |      * @dev Returns the downcasted int24 from int256, reverting on
 1087 |     |      * overflow (when the input is less than smallest int24 or
 1088 |     |      * greater than largest int24).
 1089 |     |      *
 1090 |     |      * Counterpart to Solidity's `int24` operator.
 1091 |     |      *
 1092 |     |      * Requirements:
 1093 |     |      *
 1094 |     |      * - input must fit into 24 bits
 1095 |     |      */
 1096 |     |     function toInt24(int256 value) internal pure returns (int24 downcasted) {
 1097 |     |         downcasted = int24(value);
 1098 |     |         if (downcasted != value) {
 1099 |     |             revert SafeCastOverflowedIntDowncast(24, value);
 1100 |     |         }
 1101 |     |     }
 1102 |     | 
 1103 |     |     /**
 1104 |     |      * @dev Returns the downcasted int16 from int256, reverting on
 1105 |     |      * overflow (when the input is less than smallest int16 or
 1106 |     |      * greater than largest int16).
 1107 |     |      *
 1108 |     |      * Counterpart to Solidity's `int16` operator.
 1109 |     |      *
 1110 |     |      * Requirements:
 1111 |     |      *
 1112 |     |      * - input must fit into 16 bits
 1113 |     |      */
 1114 |     |     function toInt16(int256 value) internal pure returns (int16 downcasted) {
 1115 |     |         downcasted = int16(value);
 1116 |     |         if (downcasted != value) {
 1117 |     |             revert SafeCastOverflowedIntDowncast(16, value);
 1118 |     |         }
 1119 |     |     }
 1120 |     | 
 1121 |     |     /**
 1122 |     |      * @dev Returns the downcasted int8 from int256, reverting on
 1123 |     |      * overflow (when the input is less than smallest int8 or
 1124 |     |      * greater than largest int8).
 1125 |     |      *
 1126 |     |      * Counterpart to Solidity's `int8` operator.
 1127 |     |      *
 1128 |     |      * Requirements:
 1129 |     |      *
 1130 |     |      * - input must fit into 8 bits
 1131 |     |      */
 1132 |     |     function toInt8(int256 value) internal pure returns (int8 downcasted) {
 1133 |     |         downcasted = int8(value);
 1134 |     |         if (downcasted != value) {
 1135 |     |             revert SafeCastOverflowedIntDowncast(8, value);
 1136 |     |         }
 1137 |     |     }
 1138 |     | 
 1139 |     |     /**
 1140 |     |      * @dev Converts an unsigned uint256 into a signed int256.
 1141 |     |      *
 1142 |     |      * Requirements:
 1143 |     |      *
 1144 |     |      * - input must be less than or equal to maxInt256.
 1145 |     |      */
 1146 |     |     function toInt256(uint256 value) internal pure returns (int256) {
 1147 |     |         // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive
 1148 |     |         if (value > uint256(type(int256).max)) {
 1149 |     |             revert SafeCastOverflowedUintToInt(value);
 1150 |     |         }
 1151 |     |         return int256(value);
 1152 |     |     }
 1153 |     | 
 1154 |     |     /**
 1155 |     |      * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.
 1156 |     |      */
 1157 |     |     function toUint(bool b) internal pure returns (uint256 u) {
 1158 |     |         assembly ("memory-safe") {
 1159 |     |             u := iszero(iszero(b))
 1160 |     |         }
 1161 |     |     }
 1162 |     | }
 1163 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise1/testToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./token.sol";
  5 |     | 
  6 |     | 
  7 |     | contract testToken is Token {
  8 |     | 
  9 |     |     // Token  public token;
 10 |     |     // User user;
 11 |     |     address user = msg.sender;
 12 |     |     constructor (){
 13 |     |         // token = new Token();
 14 |     |         // user  = new User();
 15 |     | 
 16 |     |         // token.transfer();
 17 |     |         // token.balances(user) = 10000;
 18 |     |         balances[user] = 10_000;
 19 |     |     }
 20 |     | 
 21 |     |     function echidna_test_Balances() public view returns(bool) {
 22 |     |         // assert(balances(user) <= 10000);
 23 |     |         return balances[user] <= 10000;
 24 |     |     }
 25 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise1/token.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | contract Ownable {
  5 |     |     address public owner = msg.sender;
  6 |     | 
  7 |     |     modifier onlyOwner() {
  8 |     |         require(msg.sender == owner, "Ownable: Caller is not the owner.");
  9 |     |         _;
 10 |     |     }
 11 |     | }
 12 |     | 
 13 |     | contract Pausable is Ownable {
 14 |     |     bool private _paused;
 15 |     | 
 16 |     |     function paused() public view returns (bool) {
 17 |     |         return _paused;
 18 |     |     }
 19 |     | 
 20 |     |     function pause() public onlyOwner {
 21 |     |         _paused = true;
 22 |     |     }
 23 |     | 
 24 |     |     function resume() public onlyOwner {
 25 |     |         _paused = false;
 26 |     |     }
 27 |     | 
 28 |     |     modifier whenNotPaused() {
 29 |     |         require(!_paused, "Pausable: Contract is paused.");
 30 |     |         _;
 31 |     |     }
 32 |     | }
 33 |     | 
 34 |     | contract Token is Ownable, Pausable {
 35 |     |     mapping(address => uint256) public balances;
 36 |     | 
 37 |     |     function transfer(address to, uint256 value) public whenNotPaused {
 38 |     |         // unchecked to save gas
 39 |     |         // require(balances[msg.sender] >= value, "Insufficient balance");
 40 |     |         // @audit just remove the below unchecked one because it is causing and underflow issue or add above require statement
 41 |     |         // unchecked {
 42 |     |             balances[msg.sender] -= value;
 43 |     |             balances[to] += value;
 44 |     |         // }
 45 |     |     }
 46 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise2/testToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./token.sol";
  5 |     | 
  6 |     | // pause i called at deployment
  7 |     | // Remove Ownership
  8 |     | 
  9 |     | 
 10 |     | contract testToken is Token {
 11 |     | 
 12 |     |     // address constant USER_1 = 0x9876543210987654321098765432109876543210;
 13 |     |     constructor () {
 14 |     |         paused();
 15 |     |         owner = address(0);
 16 |     | 
 17 |     |     }
 18 |     | 
 19 |     |     // function echidna_test_cannot_be_unpaused() public view returns(bool) {
 20 |     |     //     return balances[USER_1] == 0;
 21 |     |     // }
 22 |     | 
 23 |     |     function echidna_unpause() public view returns(bool){
 24 |     |         return (paused() == true);
 25 |     |     }
 26 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise2/token.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | contract Ownable {
  5 |     |     address public owner = msg.sender;
  6 |     |     // @audit To fix the bug we should only remove the below function  
  7 |     | 
  8 |     | 
  9 |     |     // function Owner() public {
 10 |     |     //     owner = msg.sender;
 11 |     |     // }
 12 |     | 
 13 |     |     modifier onlyOwner() {
 14 |     |         require(owner == msg.sender);
 15 |     |         _;
 16 |     |     }
 17 |     | }
 18 |     | 
 19 |     | contract Pausable is Ownable {
 20 |     |     bool private _paused;
 21 |     | 
 22 |     |     function paused() public view returns (bool) {
 23 |     |         return _paused;
 24 |     |     }
 25 |     | 
 26 |     |     function pause() public onlyOwner {
 27 |     |         _paused = true;
 28 |     |     }
 29 |     | 
 30 |     |     function resume() public onlyOwner {
 31 |     |         _paused = false;
 32 |     |     }
 33 |     | 
 34 |     |     modifier whenNotPaused() {
 35 |     |         require(!_paused, "Pausable: Contract is paused.");
 36 |     |         _;
 37 |     |     }
 38 |     | }
 39 |     | 
 40 |     | contract Token is Ownable, Pausable {
 41 |     |     mapping(address => uint256) public balances;
 42 |     | 
 43 |     |     function transfer(address to, uint256 value) public whenNotPaused {
 44 |     |         balances[msg.sender] -= value;
 45 |     |         balances[to] += value;
 46 |     |     }
 47 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise3/mintable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./token.sol";
  5 |     | 
  6 |     | contract MintableToken is Token {
  7 |     |     int256 public totalMinted;
  8 |     |     int256 public totalMintable;
  9 |     | 
 10 |     |     constructor(int256 totalMintable_) {
 11 |     |         totalMintable = totalMintable_;
 12 |     |     }
 13 |     | 
 14 |     |     //@audit To prevent this type of bug, you must ensure that value is always within the valid range of int256 before performing the cast. Add an explicit check for value:
 15 |     | 
 16 |     |     // function mint(uint256 value) public onlyOwner {
 17 |     |     //     require(value <= uint256(type(int256).max), "Value exceeds int256 range");
 18 |     |     //     require(int256(value) + totalMinted <= totalMintable, "Mint exceeds total mintable tokens");
 19 |     | 
 20 |     |     //     totalMinted += int256(value);
 21 |     |     //     balances[msg.sender] += value;
 22 |     |     // }
 23 |     | 
 24 |     |     function mint(uint256 value) public onlyOwner {
 25 |     |         require(int256(value) + totalMinted < totalMintable);
 26 |     |         // require(value <=  uint256(type(int256).max) , "Value more than the int256 ");
 27 |     |         totalMinted += int256(value);
 28 |     | 
 29 |     |         balances[msg.sender] += value;
 30 |     |     }
 31 |     | 
 32 |     | }
 33 |     |     // @audit i think their are two invariant here
 34 |     |     // 1. will be that the balances of the mag.sender should never greater than totalMinted
 35 |     |     // 2. will be that the totalMintable > totalMinted 
 36 |     |     // 3. See if the user can mint more that what is the limit 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise3/testToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | 
  5 |     | import "./mintable.sol";
  6 |     | 
  7 |     | contract testToken is MintableToken {
  8 |     | 
  9 |     |     // Create a scenario where echidna (tx.origin) becomes the owner of the contract at construction, and totalMintable is set to 10,000. Remember that Echidna needs a constructor without arguments.
 10 |     |     // Add a property to check if echidna can mint more than 10,000 tokens.
 11 |     |     // Once Echidna finds the bug, fix the issue, and re-try your property with Echidna.
 12 |     | 
 13 |     |     // @audit i think their are two invariant here
 14 |     |     // 1. will be that the balances of the msg.sender should never greater than totalMinted
 15 |     |     // 2. will be that the totalMintable > totalMinted 
 16 |     |     // 3. See if the user can mint more that what is the limit 
 17 |     | 
 18 |     |     address user = msg.sender;
 19 |     | 
 20 |     |     constructor () MintableToken(10000) {
 21 |     |         owner = user;
 22 |     |     }
 23 |     | 
 24 |     |     function echidna_user_can_mint_more_than_totalMintable() public view returns(bool) {
 25 |     |         // return totalMinted < 10000;
 26 |     |         return balances[msg.sender] <= 10_000;
 27 |     |     }
 28 |     |     // Below test could have been also performed bu the thing is than you should change the code in the mintable.sol
 29 |     |     // at line 29 --  balances[msg.sender] += value; to balances[owner] += value;
 30 |     |     // function echidna_bal_ofuser_not_greater_than_totalMinted() public view returns(bool){
 31 |     |     //     return int256(balances[owner]) == totalMinted;
 32 |     |     //     // return totalMinted <= totalMintable;
 33 |     |     // }
 34 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise3/token.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @notice The issues from exercise 1 and 2 are fixed.
  5 |     | 
  6 |     | contract Ownable {
  7 |     |     address public owner = msg.sender;
  8 |     | 
  9 |     |     modifier onlyOwner() {
 10 |     |         require(msg.sender == owner, "Ownable: Caller is not the owner.");
 11 |     |         _;
 12 |     |     }
 13 |     | }
 14 |     | 
 15 |     | contract Pausable is Ownable {
 16 |     |     bool private _paused;
 17 |     | 
 18 |     |     function paused() public view returns (bool) {
 19 |     |         return _paused;
 20 |     |     }
 21 |     | 
 22 |     |     function pause() public onlyOwner {
 23 |     |         _paused = true;
 24 |     |     }
 25 |     | 
 26 |     |     function resume() public onlyOwner {
 27 |     |         _paused = false;
 28 |     |     }
 29 |     | 
 30 |     |     modifier whenNotPaused() {
 31 |     |         require(!_paused, "Pausable: Contract is paused.");
 32 |     |         _;
 33 |     |     }
 34 |     | }
 35 |     | 
 36 |     | contract Token is Ownable, Pausable {
 37 |     |     mapping(address => uint256) public balances;
 38 |     | 
 39 |     |     function transfer(address to, uint256 value) public whenNotPaused {
 40 |     |         balances[msg.sender] -= value;
 41 |     |         balances[to] += value;
 42 |     |     }
 43 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise4/testToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./token.sol";
  5 |     | 
  6 |     | contract testToken is Token {
  7 |     |     
  8 |     |     function transfer(address to, uint256 value) public override{
  9 |     |         uint256 intialBalOfSender = balances[msg.sender];
 10 |     |         uint256 intialBalOfReciever = balances[to];
 11 |     |         super.transfer(to,value);
 12 |     |         assert(intialBalOfSender >= balances[msg.sender]);
 13 |     |         assert(intialBalOfReciever <= balances[to]);
 14 |     |     }
 15 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise4/token.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | contract Ownable {
  5 |     |     address public owner = msg.sender;
  6 |     | 
  7 |     |     function transferOwnership(address newOwner) public onlyOwner {
  8 |     |         owner = newOwner;
  9 |     |     }
 10 |     | 
 11 |     |     modifier onlyOwner() {
 12 |     |         require(msg.sender == owner, "Ownable: Caller is not the owner.");
 13 |     |         _;
 14 |     |     }
 15 |     | }
 16 |     | 
 17 |     | contract Pausable is Ownable {
 18 |     |     bool private _paused;
 19 |     | 
 20 |     |     function paused() public view returns (bool) {
 21 |     |         return _paused;
 22 |     |     }
 23 |     | 
 24 |     |     function pause() public onlyOwner {
 25 |     |         _paused = true;
 26 |     |     }
 27 |     | 
 28 |     |     function resume() public onlyOwner {
 29 |     |         _paused = false;
 30 |     |     }
 31 |     | 
 32 |     |     modifier whenNotPaused() {
 33 |     |         require(!_paused, "Pausable: Contract is paused.");
 34 |     |         _;
 35 |     |     }
 36 |     | }
 37 |     | 
 38 |     | contract Token is Ownable, Pausable {
 39 |     | 
 40 |     |     mapping(address => uint256) public balances;
 41 |     | 
 42 |     |     function transfer(address to, uint256 value) public virtual whenNotPaused {
 43 |     |         // require(balances[msg.sender] >= value ,"Insuffcient balance") ;
 44 |     |         // @audit just remove the unchecked keyword or add reuiqre statement above to check underflow and overflow 
 45 |     |         // unchecked to save gas
 46 |     |         unchecked {
 47 |     |             balances[msg.sender] -= value;
 48 |     |             balances[to] += value;
 49 |     |         }
 50 |     |     }
 51 |     | }
 52 |     | 
 53 |     | // @audit here there could be underflow issue for line 44,45
 54 |     | // msg.sender must have its initial balance or less.
 55 |     | // to must have its initial balance or more.

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise5/EchidnaNaiveReciever.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import "./FlashLoanReceiver.sol";
  6 |     | import "./NaiveReceiverLenderPool.sol";
  7 |     | 
  8 |     | contract EchidnaNaiveReciever {
  9 |     | 
 10 |     |     NaiveReceiverLenderPool  naiveReceiverLenderPool;
 11 |     |     FlashLoanReceiver  flashLoanReceiver ;
 12 |     | 
 13 |     |     uint256 public poolBalance = 1000 ether;
 14 |     |     uint256 public userBalance = 10 ether;
 15 |     | 
 16 |     |     // the lender pool should have 1000 eth of bal 
 17 |     |     // The flashloan reciever also has a bal
 18 |     |     constructor() payable {
 19 |     |         naiveReceiverLenderPool = new NaiveReceiverLenderPool();
 20 |     |         payable(address(naiveReceiverLenderPool)).transfer(poolBalance);
 21 |     |         flashLoanReceiver = new FlashLoanReceiver(payable(address(naiveReceiverLenderPool)));
 22 |     | 
 23 |     |         // address(this).balance = 2000 ether;
 24 |     |         // naiveReceiverLenderPool.receive(poolBalance);
 25 |     |         // (bool success,) = payable(address(naiveReceiverLenderPool)).call{value: poolBalance}("");
 26 |     |         // require(success, "Failed to fund the pool");
 27 |     | 
 28 |     |         // (success, ) = payable(address(flashLoanReceiver)).call{value: userBalance}("");
 29 |     |         // require(success, "Failed to fund the flash loan receiver");
 30 |     | 
 31 |     |         
 32 |     |         payable(address(flashLoanReceiver)).transfer(userBalance);
 33 |     | 
 34 |     |     }
 35 |     | 
 36 |     |     // function echidna_test_flashloan_fail() public returns(bool) {
 37 |     |     //     naiveReceiverLenderPool.flashLoan(address(flashLoanReceiver),10 ether);
 38 |     |     //     return true;
 39 |     |     // }
 40 |     | 
 41 |     |     function echidna_test_flashloan_fail_dynamic() public view returns(bool) {
 42 |     |         // naiveReceiverLenderPool.flashLoan(address(flashLoanReceiver),amount);
 43 |     |         
 44 |     |         return address(flashLoanReceiver).balance >= 10 ether;
 45 |     |     }
 46 |     | 
 47 |     | }
 48 |     | 
 49 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise5/FlashLoanReceiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import "@openzeppelin/contracts/utils/Address.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title FlashLoanReceiver
  9 |     |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 10 |     |  */
 11 |     | contract FlashLoanReceiver {
 12 |     |     using Address for address payable;
 13 |     | 
 14 |     |     address payable private pool;
 15 |     | 
 16 |     |     constructor(address payable poolAddress) {
 17 |     |         pool = poolAddress;
 18 |     |     }
 19 |     | 
 20 |     |     // Function called by the pool during flash loan
 21 |     |     function receiveEther(uint256 fee) public payable {
 22 |     |         require(msg.sender == pool, "Sender must be pool");
 23 |     | 
 24 |     |         uint256 amountToBeRepaid = msg.value + fee;
 25 |     | 
 26 |     |         require(address(this).balance >= amountToBeRepaid, "Cannot borrow that much");
 27 |     |         
 28 |     |         _executeActionDuringFlashLoan();
 29 |     |         
 30 |     |         // Return funds to pool
 31 |     |         pool.sendValue(amountToBeRepaid);
 32 |     |     }
 33 |     | 
 34 |     |     // Internal function where the funds received are used
 35 |     |     function _executeActionDuringFlashLoan() internal { }
 36 |     | 
 37 |     |     // Allow deposits of ETH
 38 |     |     receive () external payable {}
 39 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise5/NaiveReceiverLenderPool.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
  5 |     | import "@openzeppelin/contracts/utils/Address.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title NaiveReceiverLenderPool
  9 |     |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 10 |     |  */
 11 |     | contract NaiveReceiverLenderPool is ReentrancyGuard {
 12 |     | 
 13 |     |     using Address for address;
 14 |     | 
 15 |     |     uint256 private constant FIXED_FEE = 1 ether; // not the cheapest flash loan
 16 |     | 
 17 |     |     function fixedFee() external pure returns (uint256) {
 18 |     |         return FIXED_FEE;
 19 |     |     }
 20 |     | 
 21 |     |     function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant {
 22 |     | 
 23 |     |         uint256 balanceBefore = address(this).balance;
 24 |     |         require(balanceBefore >= borrowAmount, "Not enough ETH in pool");
 25 |     | 
 26 |     | 
 27 |     |         require(borrower.isContract(), "Borrower must be a deployed contract");
 28 |     |         // Transfer ETH and handle control to receiver
 29 |     |         borrower.functionCallWithValue(
 30 |     |             abi.encodeWithSignature(
 31 |     |                 "receiveEther(uint256)",
 32 |     |                 FIXED_FEE
 33 |     |             ),
 34 |     |             borrowAmount
 35 |     |         );
 36 |     |         
 37 |     |         require(
 38 |     |             address(this).balance >= balanceBefore + FIXED_FEE,
 39 |     |             "Flash loan hasn't been paid back"
 40 |     |         );
 41 |     |     }
 42 |     | 
 43 |     |     // Allow deposits of ETH
 44 |     |     receive () external payable {}
 45 |     | }
 46 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise6/CustomERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | 
  6 |     | import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  7 |     | 
  8 | *r  | contract CustomERC20 is ERC20   {
  9 |     | 
 10 | *   |     constructor() ERC20("damn","dd") {
 11 | *   |         _mint(msg.sender,type(uint256).max);
 12 |     |     }
 13 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise6/DamnValuableToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title DamnValuableToken
  9 |     |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 10 |     |  */
 11 | *r  | contract DamnValuableToken is ERC20 {
 12 |     | 
 13 |     |     // Decimals are set to 18 by default in `ERC20`
 14 | *   |     constructor() ERC20("DamnValuableToken", "DVT") {
 15 | *   |         _mint(msg.sender, type(uint256).max);
 16 |     |     }
 17 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise6/EchidnaReciever.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import "./ReceiverUnstoppable.sol";
  6 |     | // import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  7 |     | import "./DamnValuableToken.sol";
  8 |     | import "./UnstoppableLender.sol";
  9 |     | 
 10 |     | 
 11 |     | contract EchidnaReciever {
 12 |     | 
 13 |     |     address setOwner = msg.sender;
 14 |     |     IERC20 public damnValuableToken;
 15 |     |     ReceiverUnstoppable public receiverUnstoppable;
 16 |     |     UnstoppableLender public unstoppableLender;
 17 |     |     uint256 public INITIAL_BAL_In_POOL = 100000;
 18 |     |     uint256 public BAL_OF_USER = 100;
 19 |     |     uint256 balanceBefore ;
 20 |     | 
 21 |     |     constructor(){
 22 |     |         damnValuableToken = new DamnValuableToken();
 23 |     |         unstoppableLender = new UnstoppableLender(address(damnValuableToken));
 24 |     |         receiverUnstoppable = new ReceiverUnstoppable(address(unstoppableLender));
 25 |     | 
 26 |     |         damnValuableToken.approve(address(unstoppableLender), INITIAL_BAL_In_POOL);
 27 |     |         unstoppableLender.depositTokens(INITIAL_BAL_In_POOL);
 28 |     | 
 29 |     |         damnValuableToken.transfer(setOwner,BAL_OF_USER);
 30 |     |         balanceBefore = damnValuableToken.balanceOf(address(unstoppableLender));
 31 |     |     }
 32 |     | 
 33 |     |     function receiveTokens(address tokenAddress, uint256 amount) external {
 34 |     |         require(msg.sender == address(unstoppableLender), "Sender must be pool");
 35 |     |         // Return all tokens to the pool
 36 |     |         require(
 37 |     |             IERC20(tokenAddress).transfer(msg.sender, amount),
 38 |     |             "Transfer of tokens failed"
 39 |     |         );
 40 |     |     }
 41 |     | 
 42 |     |     function echidna_poolBal_is_always_equal_to_intialBal() public  returns(bool)  {
 43 |     |         // assert(unstoppableLender.poolBalance() == balanceBefore);
 44 |     |         // require(msg.sender == )
 45 |     |         unstoppableLender.flashLoan(10);
 46 |     |         // receiverUnstoppable.executeFlashLoan(10);
 47 |     |         return true;
 48 |     |     }
 49 |     | 
 50 |     | 
 51 |     | 
 52 |     | 
 53 |     | }
 54 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise6/ReceiverUnstoppable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.17;
  4 |     | 
  5 |     | import "./UnstoppableLender.sol";
  6 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title ReceiverUnstoppable
 10 |     |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 11 |     |  */
 12 |     | contract ReceiverUnstoppable {
 13 |     | 
 14 |     |     UnstoppableLender private immutable pool;
 15 |     |     address private immutable owner;
 16 |     | 
 17 |     |     constructor(address poolAddress) {
 18 |     |         pool = UnstoppableLender(poolAddress);
 19 |     |         owner = msg.sender;
 20 |     |     }
 21 |     | 
 22 |     |     // Pool will call this function during the flash loan
 23 |     |     function receiveTokens(address tokenAddress, uint256 amount) external {
 24 |     |         require(msg.sender == address(pool), "Sender must be pool");
 25 |     |         // Return all tokens to the pool
 26 |     |         require(IERC20(tokenAddress).transfer(msg.sender, amount), "Transfer of tokens failed");
 27 |     |     }
 28 |     | 
 29 |     |     function executeFlashLoan(uint256 amount) external {
 30 |     |         require(msg.sender == owner, "Only owner can execute flash loan");
 31 |     |         pool.flashLoan(amount);
 32 |     |     }
 33 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise6/UnstoppableLender.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.20;
  4 |     | 
  5 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  6 |     | import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
  7 |     | 
  8 |     | interface IReceiver {
  9 |     |     function receiveTokens(address tokenAddress, uint256 amount) external;
 10 |     | }
 11 |     | 
 12 |     | /**
 13 |     |  * @title UnstoppableLender
 14 |     |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 15 |     |  */
 16 |     | contract UnstoppableLender is ReentrancyGuard {
 17 |     | 
 18 |     |     IERC20 public immutable damnValuableToken;
 19 |     |     uint256 public poolBalance;
 20 |     | 
 21 |     |     constructor(address tokenAddress) {
 22 |     |         require(tokenAddress != address(0), "Token address cannot be zero");
 23 |     |         damnValuableToken = IERC20(tokenAddress);
 24 |     |     }
 25 |     | 
 26 |     |     function depositTokens(uint256 amount) external nonReentrant {
 27 |     |         require(amount > 0, "Must deposit at least one token");
 28 |     |         // Transfer token from sender. Sender must have first approved them.
 29 |     |         damnValuableToken.transferFrom(msg.sender, address(this), amount);
 30 |     |         poolBalance = poolBalance + amount;
 31 |     |     }
 32 |     | 
 33 |     |     function flashLoan(uint256 borrowAmount) external nonReentrant {
 34 |     |         require(borrowAmount > 0, "Must borrow at least one token");
 35 |     | 
 36 |     |         uint256 balanceBefore = damnValuableToken.balanceOf(address(this));
 37 |     |         require(balanceBefore >= borrowAmount, "Not enough tokens in pool");
 38 |     | 
 39 |     |         // Ensured by the protocol via the `depositTokens` function
 40 |     |         assert(poolBalance == balanceBefore);
 41 |     |         
 42 |     |         damnValuableToken.transfer(msg.sender, borrowAmount);
 43 |     |         
 44 |     |         IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);
 45 |     |         
 46 |     |         uint256 balanceAfter = damnValuableToken.balanceOf(address(this));
 47 |     |         require(balanceAfter >= balanceBefore, "Flash loan hasn't been paid back");
 48 |     |     }
 49 |     | }
 50 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise7/EchidnaSideEntrance.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./SideEntranceLenderPool.sol";
  5 |     | 
  6 |     | 
  7 |     | contract EchidnaSideEntrance   {
  8 |     | 
  9 |     |     SideEntranceLenderPool public pool;
 10 |     | 
 11 |     |     constructor () {
 12 |     |         pool = new SideEntranceLenderPool() ;
 13 |     | 
 14 |     |     }
 15 |     | 
 16 |     | 
 17 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise7/SideEntranceLenderPool.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | import "@openzeppelin/contracts/utils/Address.sol";
  5 |     | 
  6 |     | interface IFlashLoanEtherReceiver {
  7 |     |     function execute() external payable;
  8 |     | }
  9 |     | 
 10 |     | /**
 11 |     |  * @title SideEntranceLenderPool
 12 |     |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 13 |     |  */
 14 |     | contract SideEntranceLenderPool {
 15 |     |     using Address for address payable;
 16 |     | 
 17 |     |     mapping (address => uint256) private balances;
 18 |     | 
 19 |     |     function deposit() external payable {
 20 |     |         balances[msg.sender] += msg.value;
 21 |     |     }
 22 |     | 
 23 |     |     function withdraw() external {
 24 |     |         uint256 amountToWithdraw = balances[msg.sender];
 25 |     |         balances[msg.sender] = 0;
 26 |     |         payable(msg.sender).sendValue(amountToWithdraw);
 27 |     |     }
 28 |     | 
 29 |     |     function flashLoan(uint256 amount) external {
 30 |     |         uint256 balanceBefore = address(this).balance;
 31 |     |         require(balanceBefore >= amount, "Not enough ETH in balance");
 32 |     |         
 33 |     |         IFlashLoanEtherReceiver(msg.sender).execute{value: amount}();
 34 |     | 
 35 |     |         require(address(this).balance >= balanceBefore, "Flash loan hasn't been paid back");        
 36 |     |     }
 37 |     | }
 38 |     |  

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise8/AccountingToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol";
  6 |     | import "@openzeppelin/contracts/access/AccessControl.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title AccountingToken
 10 |     |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 11 |     |  * @notice A limited pseudo-ERC20 token to keep track of deposits and withdrawals
 12 |     |  *         with snapshotting capabilities
 13 |     |  */
 14 | *r  | contract AccountingToken is ERC20Snapshot, AccessControl {
 15 |     | 
 16 | *   |     bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
 17 | *   |     bytes32 public constant SNAPSHOT_ROLE = keccak256("SNAPSHOT_ROLE");
 18 | *   |     bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");
 19 |     | 
 20 | *   |     constructor() ERC20("rToken", "rTKN") {
 21 | *   |         _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
 22 | *   |         _setupRole(MINTER_ROLE, msg.sender);
 23 | *   |         _setupRole(SNAPSHOT_ROLE, msg.sender);
 24 | *   |         _setupRole(BURNER_ROLE, msg.sender);
 25 |     |     }
 26 |     | 
 27 | *   |     function mint(address to, uint256 amount) external {
 28 | *r  |         require(hasRole(MINTER_ROLE, msg.sender), "Forbidden");
 29 | *   |         _mint(to, amount);
 30 |     |     }
 31 |     | 
 32 | *   |     function burn(address from, uint256 amount) external {
 33 | *r  |         require(hasRole(BURNER_ROLE, msg.sender), "Forbidden");
 34 | *   |         _burn(from, amount);
 35 |     |     }
 36 |     | 
 37 | *   |     function snapshot() external returns (uint256) {
 38 | *r  |         require(hasRole(SNAPSHOT_ROLE, msg.sender), "Forbidden");
 39 | *   |         return _snapshot();
 40 |     |     }
 41 |     | 
 42 |     |     // Do not need transfer of this token
 43 |     |     /*
 44 |     |     function _transfer(address, address, uint256) internal pure override {
 45 |     |         revert("Not implemented");
 46 |     |     }*/
 47 |     | 
 48 |     |     // Do not need allowance of this token
 49 | *   |     function _approve(address, address, uint256) internal pure override {
 50 | *r  |         revert("Not implemented");
 51 |     |     }
 52 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise8/DamnValuableToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @title DamnValuableToken
  9 |     |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 10 |     |  */
 11 | *r  | contract DamnValuableToken is ERC20 {
 12 |     | 
 13 |     |     // Decimals are set to 18 by default in `ERC20`
 14 | *   |     constructor() ERC20("DamnValuableToken", "DVT") {
 15 | *   |         _mint(msg.sender, type(uint256).max);
 16 |     |     }
 17 |     | }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise8/EchidnaRewarder.sol
   1 |     | // // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.7;
   3 |     | 
   4 |     | import "./FlashLoanerPool.sol";
   5 |     | import "./RewardToken.sol";
   6 |     | import "./AccountingToken.sol";
   7 |     | import "./TheRewarderPool.sol";
   8 |     | import "./DamnValuableToken.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @notice to run echidna use following command:
  12 |     |  * npx hardhat clean && npx hardhat compile --force && echidna-test . --contract EchidnaRewarder --config ./the-rewarder.yaml
  13 |     |  */
  14 |     | 
  15 |     | // this contract is used to set fuzzing environment (to deploy all necessary contracts)
  16 | *   | contract RewarderTaskDeployer {
  17 | *   |     uint256 private TOKENS_IN_LENDER_POOL = 1_000_000 ether;
  18 | *   |     uint256 private TOKENS_PER_USER = 100 ether;
  19 |     | 
  20 | *   |     function deployPoolsAndToken()
  21 |     |         public
  22 |     |         payable
  23 |     |         returns (
  24 | *   |             DamnValuableToken,
  25 | *   |             FlashLoanerPool,
  26 | *   |             TheRewarderPool
  27 |     |         )
  28 |     |     {
  29 |     |         // deploy DamnValuableToken
  30 | *   |         DamnValuableToken token;
  31 | *   |         token = new DamnValuableToken();
  32 |     |         // deploy FlashLoanerPool
  33 | *   |         FlashLoanerPool pool;
  34 | *   |         pool = new FlashLoanerPool(address(token));
  35 |     |         // add liquidity to FlashLoanerPool deployed
  36 | *   |         token.transfer(address(pool), TOKENS_IN_LENDER_POOL);
  37 |     |         // deploy TheRewarderPool
  38 | *   |         TheRewarderPool rewarder;
  39 | *   |         rewarder = new TheRewarderPool(address(token));
  40 |     |         // deposit tokens to the rewarder pool (simulate a deposit of 4 users)
  41 | *   |         token.approve(address(rewarder), TOKENS_PER_USER * 4);
  42 | *   |         rewarder.deposit(TOKENS_PER_USER * 4);
  43 |     |         // return
  44 | *   |         return (token, pool, rewarder);
  45 |     |     }
  46 |     | }
  47 |     | 
  48 | *r  | contract EchidnaRewarder {
  49 | *   |     uint256 REWARDS_ROUND_MIN_DURATION = 5 days;
  50 |     |     uint256 flashLoanAmount;
  51 |     |     uint256 reward;
  52 |     | 
  53 |     |     FlashLoanerPool pool;
  54 |     |     TheRewarderPool rewarder;
  55 |     |     RewardToken rewardToken;
  56 |     |     DamnValuableToken damnValuableToken;
  57 |     | 
  58 |     |     bool private depositEnabled;
  59 |     |     bool private withdrawalEnabled;
  60 |     |     bool private rewardsDistributionEnabled;
  61 |     | 
  62 |     |     // set Echidna fuzzing env
  63 | *   |     constructor() payable {
  64 | *   |         RewarderTaskDeployer deployer = new RewarderTaskDeployer();
  65 | *   |         (damnValuableToken, pool, rewarder) = deployer.deployPoolsAndToken();
  66 | *   |         rewardToken = rewarder.rewardToken();
  67 |     |     }
  68 |     | 
  69 | *   |     function receiveFlashLoan(uint256 amount) external {
  70 | *r  |         require(
  71 | *   |             msg.sender == address(pool),
  72 |     |             "Only pool can call this function."
  73 |     |         );
  74 |     |         // call selected functions
  75 | *   |         selectFunctionsToCallInCallback();
  76 |     |         // get max reward amount for checking the INVARIANT
  77 | *   |         reward = rewardToken.balanceOf(address(this));
  78 |     |         // repay the loan
  79 | *   |         damnValuableToken.transfer(address(pool), amount);
  80 |     |     }
  81 |     | 
  82 |     |     /**
  83 |     |      * @notice functions to be called in callback
  84 |     |      * @dev order must be defined by a user
  85 |     |      */
  86 | *   |     function selectFunctionsToCallInCallback() internal {
  87 |     |         // deposit to the pool with prior approval
  88 | *   |         if (depositEnabled) {
  89 | *   |             damnValuableToken.approve(address(rewarder), flashLoanAmount);
  90 | *   |             rewarder.deposit(flashLoanAmount);
  91 |     |         }
  92 |     |         // withdraw from the pool
  93 | *   |         if (withdrawalEnabled) {
  94 | *   |             rewarder.withdraw(flashLoanAmount);
  95 |     |         }
  96 |     |         // distribute rewards
  97 | *   |         if (rewardsDistributionEnabled) {
  98 | *   |             rewarder.distributeRewards();
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 | *   |     function setEnableDeposit(bool _enabled) external {
 103 | *   |         depositEnabled = _enabled;
 104 |     |     }
 105 |     | 
 106 | *   |     function setEnableWithdrawal(bool _enabled) external {
 107 | *   |         withdrawalEnabled = _enabled;
 108 |     |     }
 109 |     | 
 110 | *   |     function setRewardsDistributionEnabled(bool _enabled) external {
 111 | *   |         rewardsDistributionEnabled = _enabled;
 112 |     |     }
 113 |     | 
 114 | *   |     function flashLoan(uint256 _amount) public {
 115 | *   |         uint256 lastRewardsTimestamp = rewarder.lastRecordedSnapshotTimestamp();
 116 | *r  |         require(
 117 | *   |             block.timestamp >=
 118 | *   |                 lastRewardsTimestamp + REWARDS_ROUND_MIN_DURATION,
 119 |     |             "It is useless to call flashloan if no rewards can be taken as ETH is precious."
 120 |     |         );
 121 | *r  |         require(
 122 | *   |             _amount <= damnValuableToken.balanceOf(address(pool)),
 123 |     |             "Cannot borrow more than it is in the pool."
 124 |     |         );
 125 |     |         // set _amount into storage to have the value available in selectFunctionsToCallInCallback()
 126 | *   |         flashLoanAmount = _amount;
 127 |     |         // call flashloan
 128 | *r  |         pool.flashLoan(flashLoanAmount);
 129 |     |     }
 130 |     | 
 131 |     |     /**
 132 |     |      * @notice INVARIANT: one user cannot get almost all of rewards
 133 |     |      * (max reward is 100 per turnus)
 134 |     |      */
 135 | *   |     function testRewards() public view {
 136 | *   |         assert(reward < 99 ether);
 137 |     |     }
 138 |     | }
 139 |     | // pragma solidity ^0.8.0;
 140 |     | 
 141 |     | // import "./AccountingToken.sol";
 142 |     | // import "./DamnValuableToken.sol";
 143 |     | // import "./FlashLoanerPool.sol";
 144 |     | // import "./RewardToken.sol";
 145 |     | // import "./TheRewarderPool.sol";
 146 |     | // // import ""
 147 |     | 
 148 |     | // contract setUp {
 149 |     | 
 150 |     | //     // DamnValuableToken public damnToken;
 151 |     | //     // FlashLoanerPool public flashPool;
 152 |     | //     // TheRewarderPool public rewarderPool;
 153 |     | //     // RewardToken public rewardToken;
 154 |     | //     // AccountingToken public accToken;
 155 |     | 
 156 |     | //     uint256 public poolTokenBalance = 100000;
 157 |     | //     uint256 public userTokenBalance = 100;
 158 |     | 
 159 |     | //     function deploy() public returns(DamnValuableToken,FlashLoanerPool,TheRewarderPool,AccountingToken,RewardToken) {
 160 |     | //         DamnValuableToken damnToken;
 161 |     | //         FlashLoanerPool flashPool;
 162 |     | //         TheRewarderPool rewarderPool;
 163 |     | //         RewardToken rewardToken;
 164 |     | //         AccountingToken accToken;
 165 |     | 
 166 |     | //         damnToken = new DamnValuableToken();
 167 |     | //         flashPool =  new FlashLoanerPool(address(damnToken));
 168 |     | //         rewarderPool = new TheRewarderPool(address(damnToken));
 169 |     | //         accToken = rewarderPool.accToken();
 170 |     | //         rewardToken = rewarderPool.rewardToken();
 171 |     | 
 172 |     | //         damnToken.transfer(address(flashPool), poolTokenBalance);
 173 |     |         
 174 |     | //         damnToken.approve(address(rewarderPool), userTokenBalance * 4);
 175 |     | //         rewarderPool.deposit( userTokenBalance * 4);
 176 |     | //         return (damnToken, flashPool, rewarderPool, accToken, rewardToken);
 177 |     | //     }
 178 |     | 
 179 |     | // }
 180 |     | 
 181 |     | // contract EchidnaRewarder {
 182 |     | 
 183 |     | //     uint256 public MIN_DURATION = 5 days;
 184 |     | 
 185 |     | //     DamnValuableToken public damnToken;
 186 |     | //     FlashLoanerPool public flashPool;
 187 |     | //     TheRewarderPool public rewarderPool;
 188 |     | //     RewardToken public rewardToken;
 189 |     | //     AccountingToken public accToken;
 190 |     | 
 191 |     | //     constructor() {
 192 |     | //         setUp  deployer = new setUp();
 193 |     | //         (damnToken, flashPool, rewarderPool, accToken, rewardToken) = deployer.deploy();
 194 |     | //     }
 195 |     | 
 196 |     | 
 197 |     | // }

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise8/FlashLoanerPool.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
  6 |     | import "@openzeppelin/contracts/utils/Address.sol";
  7 |     | import "./DamnValuableToken.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title FlashLoanerPool
 11 |     |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 12 |     | 
 13 |     |  * @dev A simple pool to get flash loans of DVT
 14 |     |  */
 15 | *r  | contract FlashLoanerPool is ReentrancyGuard {
 16 |     | 
 17 |     |     using Address for address;
 18 |     | 
 19 | *   |     DamnValuableToken public immutable liquidityToken;
 20 |     | 
 21 | *   |     constructor(address liquidityTokenAddress) {
 22 | *   |         liquidityToken = DamnValuableToken(liquidityTokenAddress);
 23 |     |     }
 24 |     | 
 25 |     |     // Flashloan caller should be a contract address
 26 | *   |     function flashLoan(uint256 amount) external nonReentrant {
 27 | *   |         uint256 balanceBefore = liquidityToken.balanceOf(address(this));
 28 | *r  |         require(amount <= balanceBefore, "Not enough token balance");
 29 |     | 
 30 | *r  |         require(msg.sender.isContract(), "Borrower must be a deployed contract");
 31 |     |         
 32 | *   |         liquidityToken.transfer(msg.sender, amount);
 33 |     | 
 34 | *   |         msg.sender.functionCall(
 35 | *   |             abi.encodeWithSignature(
 36 |     |                 "receiveFlashLoan(uint256)",
 37 | *   |                 amount
 38 |     |             )
 39 |     |         );
 40 |     | 
 41 | *   |         require(liquidityToken.balanceOf(address(this)) >= balanceBefore, "Flash loan not paid back");
 42 |     |     }
 43 |     | }
 44 |     | 
 45 |     | 
 46 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise8/RewardToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  6 |     | import "@openzeppelin/contracts/access/AccessControl.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title RewardToken
 10 |     |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
 11 |     |  * @dev A mintable ERC20 with 2 decimals to issue rewards
 12 |     |  */
 13 | *r  | contract RewardToken is ERC20, AccessControl {
 14 |     | 
 15 | *   |     bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
 16 |     | 
 17 | *   |     constructor() ERC20("Reward Token", "RWT") {
 18 | *   |         _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
 19 | *   |         _setupRole(MINTER_ROLE, msg.sender);
 20 |     |     }
 21 |     | 
 22 | *   |     function mint(address to, uint256 amount) external {
 23 | *r  |         require(hasRole(MINTER_ROLE, msg.sender));
 24 | *   |         _mint(to, amount);
 25 |     |     }
 26 |     | }
 27 |     | 

/Users/gurkiratsingh/Desktop/Fuzzing Exercises/src/Exercise8/TheRewarderPool.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import "./RewardToken.sol";
   6 |     | import "./DamnValuableToken.sol";
   7 |     | import "./AccountingToken.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title TheRewarderPool
  11 |     |  * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)
  12 |     | 
  13 |     |  */
  14 | *r  | contract TheRewarderPool {
  15 |     | 
  16 |     |     // Minimum duration of each round of rewards in seconds
  17 | *   |     uint256 private constant REWARDS_ROUND_MIN_DURATION = 5 days;
  18 |     | 
  19 | *   |     uint256 public lastSnapshotIdForRewards;
  20 | *   |     uint256 public lastRecordedSnapshotTimestamp;
  21 |     | 
  22 | *   |     mapping(address => uint256) public lastRewardTimestamps;
  23 |     | 
  24 |     |     // Token deposited into the pool by users
  25 | *   |     DamnValuableToken public immutable liquidityToken;
  26 |     | 
  27 |     |     // Token used for internal accounting and snapshots
  28 |     |     // Pegged 1:1 with the liquidity token
  29 | *   |     AccountingToken public accToken;
  30 |     |     
  31 |     |     // Token in which rewards are issued
  32 | *   |     RewardToken public immutable rewardToken;
  33 |     | 
  34 |     |     // Track number of rounds
  35 | *   |     uint256 public roundNumber;
  36 |     | 
  37 | *   |     constructor(address tokenAddress) {
  38 |     |         // Assuming all three tokens have 18 decimals
  39 | *   |         liquidityToken = DamnValuableToken(tokenAddress);
  40 | *   |         accToken = new AccountingToken();
  41 | *   |         rewardToken = new RewardToken();
  42 |     | 
  43 | *   |         _recordSnapshot();
  44 |     |     }
  45 |     | 
  46 |     |     /**
  47 |     |      * @notice sender must have approved `amountToDeposit` liquidity tokens in advance
  48 |     |      */
  49 | *   |     function deposit(uint256 amountToDeposit) external {
  50 | *r  |         require(amountToDeposit > 0, "Must deposit tokens");
  51 |     |         
  52 | *r  |         accToken.mint(msg.sender, amountToDeposit);
  53 | *   |         distributeRewards();
  54 |     | 
  55 | *   |         require(
  56 | *r  |             liquidityToken.transferFrom(msg.sender, address(this), amountToDeposit)
  57 |     |         );
  58 |     |     }
  59 |     | 
  60 | *   |     function withdraw(uint256 amountToWithdraw) external {
  61 | *r  |         accToken.burn(msg.sender, amountToWithdraw);
  62 | *   |         require(liquidityToken.transfer(msg.sender, amountToWithdraw));
  63 |     |     }
  64 |     | 
  65 | *   |     function distributeRewards() public returns (uint256) {
  66 | *   |         uint256 rewards = 0;
  67 |     | 
  68 | *   |         if(isNewRewardsRound()) {
  69 | *   |             _recordSnapshot();
  70 |     |         }        
  71 |     |         
  72 | *   |         uint256 totalDeposits = accToken.totalSupplyAt(lastSnapshotIdForRewards);
  73 | *   |         uint256 amountDeposited = accToken.balanceOfAt(msg.sender, lastSnapshotIdForRewards);
  74 |     | 
  75 | *   |         if (amountDeposited > 0 && totalDeposits > 0) {
  76 | *   |             rewards = (amountDeposited * 100 * 10 ** 18) / totalDeposits;
  77 |     | 
  78 | *   |             if(rewards > 0 && !_hasRetrievedReward(msg.sender)) {
  79 | *   |                 rewardToken.mint(msg.sender, rewards);
  80 | *   |                 lastRewardTimestamps[msg.sender] = block.timestamp;
  81 |     |             }
  82 |     |         }
  83 |     | 
  84 | *   |         return rewards;     
  85 |     |     }
  86 |     | 
  87 | *   |     function _recordSnapshot() private {
  88 | *   |         lastSnapshotIdForRewards = accToken.snapshot();
  89 | *   |         lastRecordedSnapshotTimestamp = block.timestamp;
  90 | *   |         roundNumber++;
  91 |     |     }
  92 |     | 
  93 | *   |     function _hasRetrievedReward(address account) private view returns (bool) {
  94 | *   |         return (
  95 | *   |             lastRewardTimestamps[account] >= lastRecordedSnapshotTimestamp &&
  96 | *   |             lastRewardTimestamps[account] <= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION
  97 |     |         );
  98 |     |     }
  99 |     | 
 100 | *   |     function isNewRewardsRound() public view returns (bool) {
 101 | *   |         return block.timestamp >= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION;
 102 |     |     }
 103 |     | }
 104 |     | 

